<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.26" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.102" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"CS144计算机网络","image":[""],"dateModified":"2026-02-13T06:35:50.000Z","author":[{"@type":"Person","name":"yedou","url":"https://yedou37.github.io"}]}</script><meta property="og:url" content="https://yedou37.github.io/courses/CS144.html"><meta property="og:site_name" content="Yedou's Notebook"><meta property="og:title" content="CS144计算机网络"><meta property="og:description" content="Lab0 Socket是什么 对应用程序来说： Socket 就是一个文件描述符（File Descriptor）。它看起来和普通文件一模一样。你可以对它进行 write()（写入数据）和 read()（读取数据）操作。 当你往普通文件的描述符里写数据，数据被存到了硬盘上。 当你往 Socket 的描述符里写数据，数据被交给了网卡，发向了世界另一端。 ..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2026-02-13T06:35:50.000Z"><meta property="article:modified_time" content="2026-02-13T06:35:50.000Z"><link rel="icon" href="/logo.jpg"><title>CS144计算机网络 | Yedou's Notebook</title><meta name="description" content="Lab0 Socket是什么 对应用程序来说： Socket 就是一个文件描述符（File Descriptor）。它看起来和普通文件一模一样。你可以对它进行 write()（写入数据）和 read()（读取数据）操作。 当你往普通文件的描述符里写数据，数据被存到了硬盘上。 当你往 Socket 的描述符里写数据，数据被交给了网卡，发向了世界另一端。 ...">
    <link rel="preload" href="/assets/style-CVnMh6PC.css" as="style"><link rel="stylesheet" href="/assets/style-CVnMh6PC.css">
    <link rel="modulepreload" href="/assets/app-Co1y7IU-.js"><link rel="modulepreload" href="/assets/CS144.html-i8OcvaeH.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container no-navbar external-link-icon has-toc" vp-container><!----><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/" aria-label="我的笔记库"><!---->我的笔记库<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><iconify-icon class="vp-icon" icon="fa6-solid:folder-open" sizing="both" width="1em" height="1em"></iconify-icon><span class="vp-sidebar-title">基础知识概览</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><iconify-icon class="vp-icon" icon="fa6-solid:folder-open" sizing="both" width="1em" height="1em"></iconify-icon><span class="vp-sidebar-title">课程笔记概览</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/courses/15445.html" aria-label="CMU-15445 数据库"><!---->CMU-15445 数据库<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/courses/CS144.html" aria-label="CS144计算机网络"><!---->CS144计算机网络<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/courses/6.5840.html" aria-label="MIT 6.5840 分布式系统"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:hubspot" sizing="both" width="1em" height="1em"></iconify-icon><!--]-->MIT 6.5840 分布式系统<!----></a></li></ul></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->CS144计算机网络</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://yedou37.github.io" target="_blank" rel="noopener noreferrer">yedou</a></span><span property="author" content="yedou"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2026/2/13</span><meta property="datePublished" content="2026-02-13T06:35:50.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 32 分钟</span><meta property="timeRequired" content="PT32M"></span><!----><!----></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><hr><h1 id="lab0" tabindex="-1"><a class="header-anchor" href="#lab0"><span>Lab0</span></a></h1><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">root@LAPTOP-NNMIV17L:~/cs144_lab#</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> telnet</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cs144.keithw.org</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> http</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Trying</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 104.196.238.229...</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Connected</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> to</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cs144.keithw.org.</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Escape</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> character</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> is</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;^]&#39;.</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /hello</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> HTTP/1.1</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Host:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cs144.keithw.org</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Connection:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> close</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">HTTP/1.1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 200</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> OK</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Date:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Tue,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 25</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Nov</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2025</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 10:13:34</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> GMT</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Server:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Apache</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Last-Modified:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Thu,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 13</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Dec</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2018</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 15:45:29</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> GMT</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ETag:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;e-57ce93446cb64&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Accept-Ranges:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bytes</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Content-Length:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 14</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Connection:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> close</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Content-Type:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> text/plain</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Hello,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> CS144!</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Connection</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> closed</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> by</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> foreign</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> host.</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">root@LAPTOP-NNMIV17L:~/cs144_lab#</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="socket是什么" tabindex="-1"><a class="header-anchor" href="#socket是什么"><span>Socket是什么</span></a></h3><ul><li><p><strong>对应用程序来说</strong>：<br> Socket 就是一个<strong>文件描述符（File Descriptor）</strong>。它看起来和普通文件一模一样。你可以对它进行 write()（写入数据）和 read()（读取数据）操作。</p><ul><li>当你往普通文件的描述符里写数据，数据被存到了<strong>硬盘</strong>上。</li><li>当你往 Socket 的描述符里写数据，数据被交给了<strong>网卡</strong>，发向了世界另一端。</li></ul><p>在普通的编程中（比如写 Python 爬虫），操作系统（OS）帮你管理 Socket，你只需要调用它。<br><strong>但在 CS144 中，你的角色变了：你要自己写一个“用户态的 TCP 协议栈”。</strong><br> 也就是说，你现在要编写那个<strong>管理 Socket 内部逻辑的代码</strong></p></li></ul><blockquote><p><strong>比喻</strong>：Socket 就像是房子墙上的<strong>插座</strong>。</p><ul><li><p>作为用户（Application），你只管把插头插进去用电（发数据），不管电是怎么来的。</p></li><li><p>现在，你是<strong>电力工程师</strong>。你需要去铺设墙里的线路，保证电流（数据）能稳定传输</p></li></ul></blockquote><h3 id="网络就是在不同机器之间传递字节流吗" tabindex="-1"><a class="header-anchor" href="#网络就是在不同机器之间传递字节流吗"><span>网络就是在不同机器之间传递字节流吗</span></a></h3><ul><li><p><strong>应用层的视角）</strong>：<br><strong>是的</strong>。应用程序（如 HTTP、SSH）认为网络就是一个连续的、可靠的、按顺序的字节流。我发 &quot;ABC&quot;，对方一定收到 &quot;ABC&quot;。</p></li><li><p><strong>网络的真实面目</strong>：<br><strong>绝对不是</strong>。互联网的最底层（IP层）传递的是<strong>数据包（Datagrams）</strong>。</p><ul><li><p>它们就像<strong>明信片</strong>。</p></li><li><p><strong>不可靠</strong>：可能会丢。</p></li><li><p><strong>乱序</strong>：你先发 A，再发 B，对方可能先收到 B，再收到 A。</p></li><li><p><strong>受限</strong>：每个包大小有限制（MTU）。</p></li></ul></li></ul><p><strong>CS144 的核心任务</strong>就是：<br><strong>在不可靠的“明信片”（IP Packet）服务之上，营造出一个可靠的“字节流”（TCP Stream）假象。</strong></p><p>TCP 协议就是那个魔术师，它在底层疯狂地重发丢失的包、把乱序的包排好队，然后告诉上层的应用程序：“嘿，这是一个完美的字节流，拿去用吧。”</p><h2 id="lab0-的工作" tabindex="-1"><a class="header-anchor" href="#lab0-的工作"><span>Lab0 的工作</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>你的电脑 (Sender)                         对方电脑 (Receiver)</span></span>
<span class="line"><span>+---------------------------+             +---------------------------+</span></span>
<span class="line"><span>|      应用程序 (Web)       |              |      应用程序 (Web)        |</span></span>
<span class="line"><span>+-------------+-------------+             +-------------^-------------+</span></span>
<span class="line"><span>              | write(&quot;hello&quot;)                          | read() -&gt; &quot;hello&quot;</span></span>
<span class="line"><span>              v                                         |</span></span>
<span class="line"><span>+-------------+-------------+             +-------------+-------------+</span></span>
<span class="line"><span>|   Lab 0: ByteStream       | &lt;---关键---&gt;|   Lab 0: ByteStream       |</span></span>
<span class="line"><span>|   (暂存数据的蓄水池)        |             |   (暂存数据的蓄水池)        |</span></span>
<span class="line"><span>+-------------+-------------+             +-------------^-------------+</span></span>
<span class="line"><span>              | pop()                                   | push()</span></span>
<span class="line"><span>              v                                         |</span></span>
<span class="line"><span>+-------------+-------------+             +-------------+-------------+</span></span>
<span class="line"><span>|   Lab 3: TCP Sender       |             |  Lab 2: TCP Receiver      |</span></span>
<span class="line"><span>|  (负责把流切成包发送)        |             |  (负责把包拼回成流)         |</span></span>
<span class="line"><span>+-------------+-------------+             +-------------^-------------+</span></span>
<span class="line"><span>              |                                         |</span></span>
<span class="line"><span>              v        (不可靠的互联网 - IP层)          |</span></span>
<span class="line"><span>    [Packet 1] ---&gt; [Packet 3] ---&gt; [Packet 2] --------/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>没有这个 <code>ByteStream</code>， TCP 协议就没法处理“网速”和“程序读写速度”不匹配的问题 —— 流量控制 Flow Control</p><h1 id="lab1-reassambler" tabindex="-1"><a class="header-anchor" href="#lab1-reassambler"><span>Lab1 reassambler</span></a></h1><p>为什么要写这个？因为互联网是<strong>不可靠</strong>的。</p><h4 id="核心概念-分组交换-packet-switching" tabindex="-1"><a class="header-anchor" href="#核心概念-分组交换-packet-switching"><span>核心概念：分组交换 (Packet Switching)</span></a></h4><p>互联网（IP 层）是基于“尽力而为”（Best-effort）交付的。当你发一张图片给朋友，图片被切成了几千个小包（Packet）。在网络中：</p><ol><li><strong>乱序 (Reordering)</strong>：第 10 个包可能比第 1 个包先到（走了不同的路由）。</li><li><strong>丢失 (Loss)</strong>：第 5 个包可能丢了（路由器堵车扔掉了）。</li><li><strong>重复 (Duplication)</strong>：第 3 个包可能收到了两次（发送端以为丢了重发了）。</li></ol><h4 id="reassembler-的角色-tcp-的接收端" tabindex="-1"><a class="header-anchor" href="#reassembler-的角色-tcp-的接收端"><span>Reassembler 的角色：TCP 的接收端</span></a></h4><p>在现实世界中（Linux 内核、Windows 网络栈），当你正在看这个网页时：</p><ol><li><strong>光缆/WiFi</strong> 传来的是物理信号。</li><li><strong>网卡</strong> 将其转为以太网帧。</li><li><strong>IP 层</strong> 识别出这是发给你的包。</li><li><strong>TCP 层 (你的 Lab 1)</strong>： <ul><li>操作系统内核里有一个极其复杂、高度优化的 Reassembler。</li><li>它看着进来的乱序数据包（Sequence Numbers），把你刚才请求的 HTML 文字拼凑好。</li><li>如果中间缺了一块（比如 index 1000-1400 丢了），TCP 就等着，不把后面的数据给浏览器，直到重传的数据填补上这个坑。</li></ul></li><li><strong>应用层 (浏览器)</strong>：调用 read() (对应 Lab 0 的 reader().pop())，拿到的就是完美的 HTML 代码。</li></ol><h2 id="具体实现" tabindex="-1"><a class="header-anchor" href="#具体实现"><span>具体实现</span></a></h2><p>传过来的数据包是乱序的 有重叠的 而我要提供给<code>bytestream</code> 的字节流一定要是按照顺序的（这一层组件默认字节流是有序的 他只管处理缓冲区的读入和写出）<br> 所以需要进行剪切 暂存 拼接</p><h3 id="流水线处理" tabindex="-1"><a class="header-anchor" href="#流水线处理"><span>流水线处理</span></a></h3><p>由于只有一个主要的方法<code>receive</code><br> 我们应该按照流水线设计这个方法 能够更好地理清思路</p><ul><li><strong>首先进行溢出检查</strong><br> 传入的idx很可能是会溢出的 保证安全是第一位</li><li>进行头部尾部裁剪<br> 头部（早于我期望的idx的数据不要）<br> 尾部（会导致bytestream溢出的数据不要）</li><li><strong>查找与合并</strong><br> 使用<code>std::map&lt;idx, std::string&gt;</code>维护所有pending的字节流片段 如果当前可以合并的话 就合并</li><li>如果拿到了期待的idx 那么就写入流 如果没有待写入的了就关闭流（收到了eof且pending bytes == 0）</li></ul><h3 id="合并两个字符串" tabindex="-1"><a class="header-anchor" href="#合并两个字符串"><span>合并两个字符串</span></a></h3><ul><li><strong>初始状态</strong>：试图通过 if-else 穷举所有可能的重叠情况（左边重叠、右边重叠、包含、被包含...）。这导致代码臃肿、难以维护且容易漏掉边界情况。</li><li><strong>现在的领悟</strong>：<strong>区间并集（Union of Intervals）</strong>。 <ul><li>不论两个区间怎么重叠，合并后的新区间永远是 <code>[min(start1, start2), max(end1, end2)]</code>。</li><li><strong>收获</strong>：在处理复杂逻辑时，先寻找数学上的<strong>不变量（Invariant</strong>或通用公式，而不是陷入具体的 Case study。这能极大地简化代码<br> 具体操作</li></ul></li><li>通过min max获得新的字节流idx边界</li><li>如果1在前面 那么就1拼上2后面可能多出的</li><li>vice versa</li></ul><h3 id="无符号整数溢出" tabindex="-1"><a class="header-anchor" href="#无符号整数溢出"><span>无符号整数溢出</span></a></h3><p>使用<code>UINT64_MAX - start &gt; size</code>可以判断是否溢出</p><h1 id="lab2" tabindex="-1"><a class="header-anchor" href="#lab2"><span>Lab2</span></a></h1><p><strong>acknowledgment</strong> means, “What’s the index of the next byte that the receiver needs so it can reassemble more of the ByteStream?” This tells the sender what bytes it needs to send or resend. <strong>Flow control</strong> means, “What range of indices is the receiver interested and willing to receive?” (a function of its available capacity). This tells the sender how much it’s allowed to send<br> 这个饰演的内容就是制作一个TCP接收器 他的作用</p><ul><li>转换TCP头部的seqno变为ByteStream中的index（从32位变为64位） <ul><li>为了实现这个 新增了一个<code>wrap32</code>类 用来wrap和unwrap <ul><li>wrap是receiver发送信息时候使用 把期望得到的idx变为seqno</li><li>unwrap是receiver与bytestream交互的时候使用 得到从0开始的idx</li></ul></li></ul></li><li>向sender发送相应信息 主要是两个 <ul><li>window size 我可以接受多大范围内的字节数 如果超出了 就可能会溢出ByteStream</li><li>ackno 我期望的下一个字节是什么 可以通过底层的ByteStream中存放的expected_idx经过wrap获得</li></ul></li></ul><p>内部通过一个map 暂时存储所有不能放入byte stream的数据（因为对于上层而言 必须保证字节流是有序完整的）<br> 收到一个数据包以后 先尝试与map中的片段合并 然后看看最早的是不是想要的index 如果是 就推入字节流 如果不是就暂存</p><h1 id="lab3-tcp-sender" tabindex="-1"><a class="header-anchor" href="#lab3-tcp-sender"><span>Lab3 TCP sender</span></a></h1><p>主要是实现重传和流量控制<br> 主要方法</p><ul><li>push<br> 在windowsize允许的情况下（window通过receiver的信息更新 窗口大小为0时设置为1 这样可以通过发送一个小数据来不断询问）发送字节流 如果这里没有要发送的了就发送时加上FIN<br> 注意这里发送的所有包要暂存 因为不能保证送到了 并且更新bytes in flight -&gt; 这会减少可用窗口</li><li>receive<br> 收到receiver的回应 根据ackseqno更新需要的seqno 并且将本地暂存的比这个ackno更早的message删掉（之前的都被收到了）并且更新window size 这个时候会归零计时器（有包被收到了）</li><li>tick<br> 由更上层的模块定时调用 每次tick的时候 会增加计时器 如果到达了RTO 说明很长时间没有包被接受了 所以要重新传第一个包（如果这个时候windowsize == 0 说明对面还没处理好 那么就正常重传即可）（如果不是 说明是网络拥堵导致的包没有传到 要指数退让）</li></ul><p>假设网络现在堵得水泄不通，路由器每秒只能处理 100 个包，但有 200 个人每秒想发 1 个包。必然有一半的包会丢。</p><h4 id="方案-a-简单增加-linear-backoff" tabindex="-1"><a class="header-anchor" href="#方案-a-简单增加-linear-backoff"><span>方案 A：简单增加 (Linear Backoff)</span></a></h4><ul><li><strong>策略</strong>：RTO = 1s, 1.1s, 1.2s, 1.3s...</li><li><strong>后果</strong>： <ul><li>你发现包丢了，过了 1 秒重传。重传的包又去挤那个已经堵死的路由器。</li><li>如果成千上万个用户都只延迟一点点就立马重传，路由器的压力<strong>并没有实质性减轻</strong>。</li><li>路由器继续丢包 -&gt; 大家继续频繁重传 -&gt; 路由器压力更大 -&gt; 丢更多的包。</li><li>这是一个<strong>恶性循环 (Positive Feedback Loop)</strong>。</li><li><strong>结果</strong>：网络吞吐量跌到 0，谁也发不出去。这就是<strong>拥塞崩溃</strong>。</li></ul></li></ul><h4 id="方案-b-指数翻倍-exponential-backoff" tabindex="-1"><a class="header-anchor" href="#方案-b-指数翻倍-exponential-backoff"><span>方案 B：指数翻倍 (Exponential Backoff)</span></a></h4><ul><li><strong>策略</strong>：RTO = 1s, 2s, 4s, 8s, 16s...</li><li><strong>后果</strong>： <ul><li>第一次重传失败，你等 2 秒。</li><li>第二次失败，你直接等 4 秒。</li><li>第三次失败，你闭嘴等 8 秒。</li><li><strong>关键点</strong>：随着重传失败次数增加，你的<strong>发送频率呈断崖式下跌</strong>。</li><li><strong>宏观效果</strong>：如果网络中所有人都在使用这个策略，当拥塞发生时，大家都会迅速“闭嘴”，停止向网络灌水。</li><li><strong>结果</strong>：路由器的队列迅速排空，拥塞解除，网络恢复正常。</li></ul></li></ul><h3 id="如何设置rto" tabindex="-1"><a class="header-anchor" href="#如何设置rto"><span>如何设置RTO</span></a></h3><h4 id="情况-a-rto-设置得太短-rto-rtt" tabindex="-1"><a class="header-anchor" href="#情况-a-rto-设置得太短-rto-rtt"><span>情况 A：RTO 设置得太短 (RTO &lt; RTT)</span></a></h4><ul><li><strong>场景</strong>： <ul><li>真实路况（RTT）需要 200ms。</li><li>你是个急脾气，设置 RTO = 100ms。</li></ul></li><li><strong>后果</strong>： <ul><li>100ms 到了，你没收到 ACK，以为丢了，于是重传。</li><li>其实包没丢，只是还在路上。</li><li>结果：接收方收到了两份一模一样的数据（浪费带宽）。你的网卡发了双倍的数据。</li><li><strong>这叫“虚假重传” (Spurious Retransmission)。</strong></li></ul></li></ul><h4 id="情况-b-rto-设置得太长-rto-rtt" tabindex="-1"><a class="header-anchor" href="#情况-b-rto-设置得太长-rto-rtt"><span>情况 B：RTO 设置得太长 (RTO &gt;&gt; RTT)</span></a></h4><ul><li><strong>场景</strong>： <ul><li>真实路况（RTT）只要 20ms。</li><li>你是个慢郎中，设置 RTO = 5000ms (5秒)。</li></ul></li><li><strong>后果</strong>： <ul><li>包真的在第 10ms 的时候丢了。</li><li>你傻傻地等了 5 秒钟才意识到不对劲，才重传。</li><li>用户体验：网页卡住了 5 秒，转圈圈。</li><li><strong>这叫“延迟过大”。</strong></li></ul></li></ul><h3 id="rtt动态估算" tabindex="-1"><a class="header-anchor" href="#rtt动态估算"><span>RTT动态估算</span></a></h3><p>在 Linux/Windows 内核中，TCP 使用一套统计学公式来实时计算 RTO。<br> 它维护两个变量：</p><ol><li><strong>SRTT (Smoothed RTT)</strong>：平滑后的 RTT 平均值（过滤掉偶尔的抖动）。</li><li><strong>RTTVAR (RTT Variance)</strong>：RTT 的波动幅度（方差）。</li></ol><p><strong>计算公式（经典版）：</strong></p><blockquote><p><strong>RTO = SRTT + 4 × RTTVAR</strong></p></blockquote><ul><li><p>如果网络很稳（RTTVAR 很小），RTO 就紧贴着 SRTT，丢包反应极快。</p></li><li><p>如果网络很抖（一会儿 20ms 一会儿 500ms，RTTVAR 很大），RTO 就会自动变大，留出足够的“安全余量” (Safety Margin)，防止误判</p></li><li><p><strong>RTT (往返时间)</strong> 是<strong>物理现实</strong>，是网络快慢的体现。</p></li><li><p><strong>RTO (重传超时)</strong> 是<strong>逻辑决策</strong>，是发送方设定的“耐心阈值”。</p></li><li><p><strong>重传机制</strong> 就是在 <strong>“太快重传浪费带宽”</strong> 和 <strong>“太慢重传影响体验”</strong> 之间寻找平衡的艺术。</p></li></ul><h3 id="快速重传" tabindex="-1"><a class="header-anchor" href="#快速重传"><span>快速重传</span></a></h3><ul><li><strong>场景</strong>：你发了 1, 2, 3, 4。对方收到了 1，但是 2 丢了，然后对方收到了 3, 4。</li><li><strong>机制</strong>： <ul><li>收到 3 时，对方发现 2 没到，于是回一个“我想要 2”的 ACK（ACK=2）。</li><li>收到 4 时，对方又回一个“我想要 2”的 ACK。</li><li>发送方一旦收到 <strong>3 个重复的 ACK (Triple Duplicate ACK)</strong>，它就知道：“别等超时了，第 2 个包肯定丢了，虽然连接没断。”</li><li><strong>动作</strong>：立即重传 2 号包。</li></ul></li></ul><h1 id="lab4" tabindex="-1"><a class="header-anchor" href="#lab4"><span>Lab4</span></a></h1><p>将之前的TCP sender receiver应用到现实的网络传输中</p><p>祝贺你完成了 CS144 最具挑战性的 Lab 之一！能够独立排查出网络层面的配置问题是非常宝贵的经验。</p><p>这就为你总结一份适合写在博客里的 <strong>CS144 Lab 4 WSL2 网络配置排坑指南</strong>。你可以根据自己的风格进行修改。</p><hr><h2 id="解决-wsl2-下-webget-连接超时的问题" tabindex="-1"><a class="header-anchor" href="#解决-wsl2-下-webget-连接超时的问题"><span>解决 WSL2 下 webget 连接超时的问题</span></a></h2><h3 id="_1-问题现象" tabindex="-1"><a class="header-anchor" href="#_1-问题现象"><span>1. 问题现象</span></a></h3><p>在完成 TCP Sender 和 Receiver 的代码后，通过了本地的所有测试，但在运行 Lab 4 的 <code>webget</code> 访问公网（如 <code>cs144.keithw.org</code>）时，程序会一直卡在 <code>connect</code> 阶段直到超时。</p><p><strong>具体表现：</strong></p><ul><li>运行 <code>./build/apps/tcp_native</code> 和 <code>./build/apps/tcp_ipv4</code> 进行本地双机通讯完全正常。</li><li>运行 <code>cmake --build build --target check_webget</code> 报错：<div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>Test #2: t_webget .........................***Timeout  15.06 sec</span></span>
<span class="line"><span>DEBUG: Function called: get_URL( &quot;cs144.keithw.org&quot;, &quot;/nph-hasher/xyzzy&quot; )</span></span>
<span class="line"><span>DEBUG: minnow connecting to 104.196.238.229:80...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>代码逻辑检查无误，且本地握手成功，说明 TCP 协议栈实现没有问题。</li></ul><h3 id="_2-问题分析" tabindex="-1"><a class="header-anchor" href="#_2-问题分析"><span>2. 问题分析</span></a></h3><p>既然代码没错，问题一定出在<strong>网络环境</strong>上。<br> CS144 使用 <code>TUN</code> 虚拟网卡（<code>tun144</code>）将用户态 TCP 协议栈产生的数据包发送给 Linux 内核。</p><p>在 WSL2 环境下（尤其是安装了 <strong>Docker</strong> 的环境），网络包的流向如下：</p><ol><li><strong>发出：</strong> 你的程序 -&gt; <code>tun144</code> -&gt; Linux Kernel。</li><li><strong>转发判定：</strong> Kernel 发现目标 IP 是外网 IP，需要进行 IP Forwarding（转发）。</li><li><strong>防火墙拦截（关键点）：</strong> 数据包进入 <code>iptables</code> 的 <code>FORWARD</code> 链。由于 Docker 为了安全隔离，通常会将 <code>FORWARD</code> 链的默认策略设为 <code>DROP</code>（丢弃）。</li><li><strong>结果：</strong> 数据包在转发阶段被防火墙丢弃，根本没有到达 <code>POSTROUTING</code> 链进行 NAT（伪装），也发不到公网。</li></ol><p><strong>证据：</strong><br> 通过 <code>sudo iptables -t nat -L -v -n</code> 查看，发现 <code>POSTROUTING</code> 链的包计数为 0，而 <code>Chain DOCKER</code> 存在，说明 Docker 接管了防火墙规则。</p><h3 id="_3-解决方案" tabindex="-1"><a class="header-anchor" href="#_3-解决方案"><span>3. 解决方案</span></a></h3><p>我们需要手动允许通过 <code>tun144</code> 接口的转发流量。</p><h4 id="第一步-清理环境" tabindex="-1"><a class="header-anchor" href="#第一步-清理环境"><span>第一步：清理环境</span></a></h4><p>防止之前的测试残留导致设备占用 (<code>Device or resource busy</code>)。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 杀掉占用 tun 设备的进程</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fuser</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -k</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /dev/net/tun</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 删除旧设备</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ip</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> tuntap</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> del</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> mode</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> tun</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> tun144</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="第二步-初始化-tun-设备与-nat" tabindex="-1"><a class="header-anchor" href="#第二步-初始化-tun-设备与-nat"><span>第二步：初始化 TUN 设备与 NAT</span></a></h4><p>使用 Lab 自带的脚本建立基础网络环境（创建设备、开启 IP 转发、设置基础 NAT）。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 重启 tun144 配置</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ./scripts/tun.sh</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> restart</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 144</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="第三步-添加防火墙放行规则" tabindex="-1"><a class="header-anchor" href="#第三步-添加防火墙放行规则"><span>第三步：添加防火墙放行规则</span></a></h4><p>这是最关键的一步。强制允许进出 <code>tun144</code> 接口的转发流量。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 允许从 tun144 发出的包转发到外网</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> iptables</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -I</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> FORWARD</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -i</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> tun144</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -j</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ACCEPT</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 允许从外网回来的包转发给 tun144</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> iptables</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -I</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> FORWARD</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> tun144</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -j</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ACCEPT</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>注：<code>-I</code> (Insert) 会把规则插到最前面，优先级高于 Docker 的 DROP 规则。</em></p><h4 id="第四步-验证" tabindex="-1"><a class="header-anchor" href="#第四步-验证"><span>第四步：验证</span></a></h4><p>再次运行测试，顺利通过！</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cmake</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --build</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> build</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --target</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> check_webget</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="数据分析" tabindex="-1"><a class="header-anchor" href="#数据分析"><span>数据分析</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Start: 2025-12-</span></span>
<span class="line"><span>HOST: LAPTOP                      Loss%   Snt   Last   Avg  Best  Wrst StDev</span></span>
<span class="line"><span>  1.|-- LAPTOP                     0.0%     1    1.0   1.0   1.0   1.0   0.0</span></span>
<span class="line"><span>  2.|-- 10.194.0.1                 0.0%     1   46.1  46.1  46.1  46.1   0.0</span></span>
<span class="line"><span>  3.|-- 10.3.8.21                  0.0%     1   15.3  15.3  15.3  15.3   0.0</span></span>
<span class="line"><span>  4.|-- ???                       100.0     1    0.0   0.0   0.0   0.0   0.0</span></span>
<span class="line"><span>  5.|-- 210.32.127.13              0.0%     1   19.6  19.6  19.6  19.6   0.0</span></span>
<span class="line"><span>  6.|-- 100.64.171.2               0.0%     1   26.4  26.4  26.4  26.4   0.0</span></span>
<span class="line"><span>  7.|-- 100.64.71.2                0.0%     1   15.9  15.9  15.9  15.9   0.0</span></span>
<span class="line"><span>  8.|-- ???                       100.0     1    0.0   0.0   0.0   0.0   0.0</span></span>
<span class="line"><span>  9.|-- 101.4.118.250              0.0%     1   18.0  18.0  18.0  18.0   0.0</span></span>
<span class="line"><span> 10.|-- 101.4.117.30               0.0%     1   63.5  63.5  63.5  63.5   0.0</span></span>
<span class="line"><span> 11.|-- 100.64.62.1                0.0%     1   68.6  68.6  68.6  68.6   0.0</span></span>
<span class="line"><span> 12.|-- 101.4.116.118              0.0%     1   71.3  71.3  71.3  71.3   0.0</span></span>
<span class="line"><span> 13.|-- ???                       100.0     1    0.0   0.0   0.0   0.0   0.0</span></span>
<span class="line"><span> 14.|-- ???                       100.0     1    0.0   0.0   0.0   0.0   0.0</span></span>
<span class="line"><span> 15.|-- ???                       100.0     1    0.0   0.0   0.0   0.0   0.0</span></span>
<span class="line"><span> 16.|-- ???                       100.0     1    0.0   0.0   0.0   0.0   0.0</span></span>
<span class="line"><span> 17.|-- 210.25.189.237             0.0%     1   98.7  98.7  98.7  98.7   0.0</span></span>
<span class="line"><span> 18.|-- 210.25.187.54              0.0%     1  111.5 111.5 111.5 111.5   0.0</span></span>
<span class="line"><span> 19.|-- 210.25.189.134             0.0%     1  311.5 311.5 311.5 311.5   0.0</span></span>
<span class="line"><span> 20.|-- fourhundredge-0-0-0-1.407  0.0%     1  274.5 274.5 274.5 274.5   0.0</span></span>
<span class="line"><span> 21.|-- hpr-svl-agg10--internet2r  0.0%     1  235.9 235.9 235.9 235.9   0.0</span></span>
<span class="line"><span> 22.|-- hpr-emvl1-agg-01--svl-agg  0.0%     1  231.0 231.0 231.0 231.0   0.0</span></span>
<span class="line"><span> 23.|-- 137.164.26.241             0.0%     1  227.8 227.8 227.8 227.8   0.0</span></span>
<span class="line"><span> 24.|-- campus-ial-nets-b-vl1120.  0.0%     1  235.4 235.4 235.4 235.4   0.0</span></span>
<span class="line"><span> 25.|-- ???                       100.0     1    0.0   0.0   0.0   0.0   0.0</span></span>
<span class="line"><span> 26.|-- web.stanford.edu           0.0%     1  276.5 276.5 276.5 276.5   0.0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第2跳：内网网关 (<code>10.194.0.1</code>)，延迟约46ms</li><li>第3跳：另一个内网节点 (<code>10.3.8.21</code>)，延迟约15ms</li><li>第4跳：信息缺失 (<code>???</code>)，可能是防火墙阻止了回应</li><li>第5跳：公网地址 (<code>210.32.127.13</code>)，延迟约19ms</li><li>第6-7跳：运营商网络节点 (<code>100.64.x.x</code> 系列)，延迟在15-26ms之间</li><li>第8跳：再次信息缺失</li><li>第9-12跳：继续通过公网和运营商网络，延迟逐渐增加到71ms</li><li>第13-16跳：连续几跳信息缺失，可能遇到多个无法响应的设备</li><li>第17-19跳：公网地址 (<code>210.25.x.x</code> 系列)，延迟显著增加到98-311ms</li><li>第20-24跳：进入美国互联网主干网，包括 Internet2 研究教育网络</li><li>第25跳：信息缺失</li><li>第26跳：最终到达目标 <code>web.stanford.edu</code>，总延迟约为276ms</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>==============================</span></span>
<span class="line"><span>      ANALYSIS REPORT      </span></span>
<span class="line"><span>==============================</span></span>
<span class="line"><span>1. Overall Delivery Rate: 99.1623%</span></span>
<span class="line"><span>2. Longest Success Burst: 155 packets</span></span>
<span class="line"><span>3. Longest Loss Burst:    2 packets</span></span>
<span class="line"><span>------------------------------</span></span>
<span class="line"><span>4. Conditional Probability:</span></span>
<span class="line"><span>   P(Success | Success):  99.3606%</span></span>
<span class="line"><span>   P(Success | Failure):  75.6757%</span></span>
<span class="line"><span>   (Compare to Uncond P): 99.1623%</span></span>
<span class="line"><span>   -&gt; Conclusion: Losses are BURSTY (Loss predicts more loss).</span></span>
<span class="line"><span>------------------------------</span></span>
<span class="line"><span>5. Min RTT: 212.0 ms</span></span>
<span class="line"><span>6. Max RTT: 774.0 ms</span></span>
<span class="line"><span>==============================</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>![[Pasted image 20251205164547.png]]<br> ![[Pasted image 20251205164604.png]]</p><ul><li>看到一个陡峭的上升，然后在尾部有一条长长的尾巴（Long Tail）。</li><li><strong>含义</strong>：绝大多数时候，RTT 接近最小值。但偶尔会有非常高的延迟。<br> ![[Pasted image 20251205164627.png]]</li></ul><h5 id="_1-密集的蓝色团块-the-cluster-左下角" tabindex="-1"><a class="header-anchor" href="#_1-密集的蓝色团块-the-cluster-左下角"><span>1. 密集的蓝色团块 (The Cluster) - 左下角</span></a></h5><ul><li><strong>位置</strong>：大约在 (220ms, 220ms) 坐标处。</li><li><strong>含义</strong>：这是网络的<strong>空闲状态 (Steady State)</strong>。</li><li>绝大多数时候，网络是不拥堵的。包一来一回，只花了物理传播时间。因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 都没排队，所以它们的值都很小且相等，聚集在对角线上。</li></ul><h5 id="_2-沿对角线延伸的尾巴-the-diagonal-tail-红色线方向" tabindex="-1"><a class="header-anchor" href="#_2-沿对角线延伸的尾巴-the-diagonal-tail-红色线方向"><span>2. 沿对角线延伸的尾巴 (The Diagonal Tail) - 红色线方向</span></a></h5><ul><li><strong>现象</strong>：点沿着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 红线向右上角延伸。</li><li><strong>含义</strong>：<strong>持续的拥堵 (Persistent Congestion)</strong>。</li><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">RTT_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 300ms（说明排队了），那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">RTT_{N+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">RT</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 往往也是 300ms 左右。这说明队列长度在这一段时间内保持稳定（既没变长也没变短）。</li><li><strong>结论</strong>：这就是为什么图里会有一条斜线。<strong>延迟是高度自相关的</strong>。</li></ul><h5 id="_3-垂直向上的散点-vertical-spread" tabindex="-1"><a class="header-anchor" href="#_3-垂直向上的散点-vertical-spread"><span>3. 垂直向上的散点 (Vertical Spread)</span></a></h5><ul><li><strong>位置</strong>：X轴还在 220ms 左右，但 Y轴突然飙升到 300ms+。</li><li><strong>含义</strong>：<strong>突发流量 (Traffic Burst)</strong>。</li><li>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个包发过去时，队列还是空的（RTT低）；但在发 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个包的这 0.2秒 间隙里，<strong>突然有别人的流量（Cross Traffic）涌入了路由器</strong>，导致第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个包被迫排长队。</li></ul><h5 id="_4-水平向右的散点-horizontal-spread" tabindex="-1"><a class="header-anchor" href="#_4-水平向右的散点-horizontal-spread"><span>4. 水平向右的散点 (Horizontal Spread)</span></a></h5><ul><li><strong>位置</strong>：X轴在 300ms+，但 Y轴回落到 220ms。</li><li><strong>含义</strong>：<strong>拥塞缓解 (Congestion Relief)</strong>。</li><li>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个包还在排队，但等到发 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个包时，路由器的队列已经处理完了，网络恢复畅通。</li></ul><h4 id="_1-交付率-delivery-rate-与-丢包突发-loss-bursts" tabindex="-1"><a class="header-anchor" href="#_1-交付率-delivery-rate-与-丢包突发-loss-bursts"><span>1. 交付率 (Delivery Rate) 与 丢包突发 (Loss Bursts)</span></a></h4><ul><li><strong>现象</strong>：交付率通常很高（比如 98%），但一旦丢包，往往不是丢 1 个，而是连续丢 3 个、5 个甚至更多（Longest Loss Burst）。</li><li><strong>原因</strong>：<strong>路由器的缓冲区（Buffer）是有限的</strong>。 <ul><li>当网络拥堵时，路由器的队列满了（Tail Drop）。此时，所有新到达的包都会被扔掉，直到队列腾出空间。</li><li>这导致丢包往往是<strong>成批出现</strong>的（Bursty），而不是随机均匀分布的。</li></ul></li><li><strong>TCP 的应对策略</strong>： <ul><li><strong>累计确认 (Cumulative ACK)</strong>：TCP 不会每收到一个包就确认一个，而是确认“在这个序号之前的所有包都收到了”。这样即使 ACK 丢了一些，只要后续的 ACK 到了，前面的也能被确认。<strong>（这个机制是针对sender的 如果ACK包丢了也没问题 而不是会使劲重传前面的数据包）</strong></li><li><strong>快速重传 (Fast Retransmit)</strong>：如果接收方收到 3 个重复的 ACK（说明中间丢了一个，但后面的到了），发送方就知道“出事了”，不等待超时定时器（RTO）到期，立即重传。这是专门为了应对非连续丢包设计的，但在突发丢包面前，TCP 往往只能退回到超时重传。</li></ul></li></ul><h4 id="_2-条件概率-conditional-probability" tabindex="-1"><a class="header-anchor" href="#_2-条件概率-conditional-probability"><span>2. 条件概率 (Conditional Probability)</span></a></h4><ul><li><strong>现象</strong>：P(Success | Failure) 通常远小于 P(Success | Success)。 <ul><li>翻译一下：如果上一个包成功了，下一个包大概率也会成功；但如果上一个包丢了，下一个包大概率也会丢</li></ul></li><li><strong>原因</strong>：<strong>网络状态具有相关性（Memory）</strong>。拥塞不是瞬间消失的，路由器队列排满需要时间消化。</li><li><strong>TCP 的应对策略</strong>： <ul><li><strong>慢启动 (Slow Start) 与 拥塞避免</strong>：既然丢包意味着网络“生病了”（拥堵），TCP 在检测到丢包后，会<strong>大幅度</strong>减小发送窗口（Congestion Window），让网络缓一缓，而不是继续头铁地重发数据，那样只会加剧拥堵。</li></ul></li></ul><h4 id="_3-rtt-最小值-min-rtt" tabindex="-1"><a class="header-anchor" href="#_3-rtt-最小值-min-rtt"><span>3. RTT 最小值 (Min RTT)</span></a></h4><ul><li><strong>含义</strong>：这是物理极限。 <ul><li>Min RTT ≈ <strong>传播延迟</strong> (光在光纤中跑的时间) + <strong>处理延迟</strong> (路由器转发的时间)。</li><li>这个值与网络拥堵无关，只与物理距离有关。</li></ul></li><li><strong>作用</strong>：TCP 需要用这个值来计算“基准线”，任何超过这个值的延迟，都是因为“排队”造成的。</li></ul><h4 id="_4-rtt-最大值-max-rtt-与-抖动" tabindex="-1"><a class="header-anchor" href="#_4-rtt-最大值-max-rtt-与-抖动"><span>4. RTT 最大值 (Max RTT) 与 抖动</span></a></h4><ul><li><strong>含义</strong>：Max RTT ≈ Min RTT + <strong>最大排队延迟</strong>。</li><li><strong>现象</strong>：Max RTT 可能是 Min RTT 的好几倍（比如 Min 200ms, Max 500ms）。</li><li><strong>TCP 的应对策略</strong>： <ul><li><strong>RTO (Retransmission Timeout) 计算</strong>：TCP Sender 必须动态计算超时时间。</li><li>如果 RTO 设得太短（比如按 Min RTT 设），网络只是稍微堵一下，TCP 就以为包丢了进行重传，导致网络更堵（伪重传）。</li><li>如果 RTO 设得太长（比如按 Max RTT 设），丢包后恢复得太慢，用户体验极差。</li><li>所以 TCP 使用 <strong>EWMA (指数加权移动平均)</strong> 算法（SRTT 和 RTTVAR）来平滑这些抖动，算出一个合理的 RTO。</li></ul></li></ul><h3 id="总结-现实网络要怎么样" tabindex="-1"><a class="header-anchor" href="#总结-现实网络要怎么样"><span>总结 - 现实网络要怎么样？</span></a></h3><p>通过这些图表和数据，CS144 Lab 4 想让你明白，你在 Lab 1-3 写的 TCP 协议栈必须具备以下能力才能在真实互联网中生存：</p><p>kkk通过这些图表和数据，CS144 Lab 4 想让你明白，你在 Lab 1-3 写的 TCP 协议栈必须具备以下能力才能在真实互联网中生存：</p><ol><li><strong>适应性 (Adaptability)</strong>：你不能硬编码一个超时时间（比如 <code>const int timeout = 1000</code>）。你必须根据 RTT 的测量值（那张图的分布）动态调整 RTO。</li><li><strong>保守性 (Conservatism)</strong>：看到丢包（Bursty Loss），必须认为是网络堵了，要主动减速（拥塞控制）。</li><li><strong>鲁棒性 (Robustness)</strong>：面对 ACK 丢失、乱序（图中的抖动会导致乱序到达），你的 Receiver 必须能利用 <code>reassembler</code> 正确重组数据，你的 Sender 必须能正确处理重复 ACK。</li></ol><h2 id="socket实现" tabindex="-1"><a class="header-anchor" href="#socket实现"><span>Socket实现</span></a></h2><h3 id="socket" tabindex="-1"><a class="header-anchor" href="#socket"><span>Socket</span></a></h3><p>本质上就是一个文件 提供一个读和写的接口 对于两端的计算机来说 传输数据就是从这个位置读写 我不需要考虑任何中间传输过程中的问题 比如乱序 拥塞 丢包等等</p><p>在 Linux/Unix 中，“一切皆文件”。但是，网络 socket 和本地文件最大的区别在于：<strong>文件存在硬盘上，而 socket 连接需要先建立通道。</strong></p><p>所以在使用socket的时候 要进行bind connect等等操作</p><p>我们可以用 <strong>“打电话”</strong> 来比喻：</p><ol><li><strong>Socket (创建 socket)</strong>： <ul><li>你买了一部电话机（或者打开了电话 App）。现在你有一个可以用来通话的设备，但还没连线。</li></ul></li><li><strong>Bind (绑定)</strong>： <ul><li><strong>含义</strong>：给你的电话机插上一张 SIM 卡，分配一个 <strong>电话号码（IP + Port）</strong>。</li><li><strong>为什么需要</strong>：如果你只是想打给别人（Client），你其实不需要主动 Bind（操作系统会自动给你分配一个临时的），因为别人不需要知道你的号码。但如果你是 <strong>服务器（Server）</strong>，你必须 Bind，否则别人不知道打哪个号码才能找到你。</li></ul></li><li><strong>Connect (连接)</strong>： <ul><li><strong>含义</strong>：你在电话机上输入对方的号码，并按下“拨号”键。</li><li><strong>动作</strong>：这是 <strong>客户端（Client）</strong> 发起的动作。它触发了 TCP 的三次握手（SYN -&gt; ...）。</li></ul></li><li><strong>Listen &amp; Accept (监听与接受)</strong>： <ul><li><p><strong>Listen</strong>：把电话设为“响铃模式”，准备好接听。</p></li><li><p><strong>Accept</strong>：电话响了，你拿其听筒（建立连接）。这会产生一个新的 socket 专门用于和这个打电话进来的人通话。</p></li><li><p><strong>监听 Socket (Listen Socket)</strong>：只有一个，一直存在，只负责“拉客”（处理握手）。</p></li><li><p><strong>已连接 Socket (Connected Socket)</strong>：accept 每成功一次就会产生一个新的。如果有 100 个客户同时在线，就会有 1 个监听 Socket + 100 个已连接 Socket。</p></li></ul></li></ol><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;sys/socket.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;netinet/in.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;unistd.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;cstring&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 第一步：创建监听 Socket (迎宾员)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // AF_INET = IPv4, SOCK_STREAM = TCP</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> listen_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(AF_INET, SOCK_STREAM, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (listen_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) { </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">perror</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;socket failed&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 第二步：Bind (告诉大家我在哪)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    sockaddr_in address;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    address</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">sin_family</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> AF_INET;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    address</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">sin_addr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">s_addr</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> INADDR_ANY;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 监听本机所有网卡</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    address</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">sin_port</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> htons</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8080</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       // 端口 8080</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">bind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(listen_fd, (sockaddr</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">address, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(address)) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        perror</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;bind failed&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 第三步：Listen (开始营业)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 3 表示等待队列的长度</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">listen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(listen_fd, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        perror</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;listen failed&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Waiting for connections...&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 第四步：Accept (关键步骤！)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 这一步会阻塞，直到有客户端 connect 过来并完成三次握手。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 注意：listen_fd 还是那个 listen_fd，它没变。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 返回值 new_socket_fd 是一个全新的文件描述符！</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        sockaddr_in client_addr;</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">        socklen_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> addrlen </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(client_addr);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 此时，三次握手已经完成，OS 把建立好的连接交给你</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new_socket_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(listen_fd, (sockaddr</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">client_addr, </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">addrlen);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (new_socket_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            perror</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;accept failed&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            continue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;New connection accepted! FD: &quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new_socket_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 第五步：读写数据 (使用新 Socket)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 这里可以使用多线程或者 fork() 来专门处理这个连接</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 为了演示简单，我们在主线程直接处理（但这会阻塞其他新连接）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        char</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 注意：我们是对 new_socket_fd 进行读写，而不是 listen_fd</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(new_socket_fd, buffer, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Client said: &quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> buffer </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> char*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> hello </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Hello from Server&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        send</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(new_socket_fd, hello, </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">strlen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(hello), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 第六步：关闭连接</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ==========================================</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 只关闭和当前客户端的通话，listen_fd 依然在循环外存活</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(new_socket_fd); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 服务器关闭时才关掉监听</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(listen_fd);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上是一个服务端代码的示例 但是这个服务端只能处理一个客户端的连接</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> handle_client</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> socket_fd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 这里是子线程：专门负责读写数据</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(socket_fd, ...);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(socket_fd, ...);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(socket_fd);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> listen_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 建立监听</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    listen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(listen_fd, ...);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 1. 主线程阻塞在这里等待新连接</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(listen_fd, ...);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 2. 一旦有新连接，创建一个新线程去处理它</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // std::thread 会启动一个新的执行流</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        std::thread </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(handle_client, new_fd);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 3. 让子线程自己去跑，主线程不管了，继续回到循环开头 accept</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">detach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的处理多客户端连接的方法是创建多个线程 对于么个连接 都创建新的线程detach出去 然他单独执行 这样主socket的线程只需要无限循环并且建立连接就行了</p><p>另一个更好的实现方法是IO多路复用</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> listen_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 创建一个 epoll 实例 (Linux 下的高效列表)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> epoll_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> epoll_create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(...);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 把 listen_fd 加入监听列表</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    add_to_epoll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(epoll_fd, listen_fd);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 1. 阻塞在这里。等待“任何事件”发生</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 如果没人发数据，也没人连，我就睡觉。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 一旦有人发数据，或者有人连，我立刻醒来，返回一个 active_events 列表</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> epoll_wait</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(epoll_fd, active_events, ...);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n; i</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> active_events</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i].</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">fd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> listen_fd) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 说明有新连接！</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> new_fd </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(listen_fd, ...);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 把新连接也加入到 epoll 列表里盯着</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">                add_to_epoll</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(epoll_fd, new_fd);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 说明某个已连接的客户端发数据来了</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">                read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(fd, ...);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 处理一下数据，如果处理得快，直接在这里回复</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="tcpminnowsocket源码结构" tabindex="-1"><a class="header-anchor" href="#tcpminnowsocket源码结构"><span>TCPMinnowSocket源码结构</span></a></h2><h3 id="地基-filedescriptor" tabindex="-1"><a class="header-anchor" href="#地基-filedescriptor"><span>地基 <code>FileDescriptor</code></span></a></h3><p>在Linux下 可以使用 <code>int fd</code> 来获取和访问文件资源 这个类的核心作用就是把这个文件描述符变成符合RAII的安全的cpp对象<br> 首先定义一个私有类</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FDWrapper</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> fd_;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	~FDWrapper</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">		::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(fd_);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 这里表示优先去全局作用域找这个方法 而不是当前类</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再在类中持有一个</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::shared_ptr</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">FDWrapper</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> internal_fd_;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>还需要封装一个读写的接口</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">cosnt</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> StringViewRange</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> buffers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> thread_local</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::vector</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">iovec</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> iovecs;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	// buffer -&gt; iovecs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(iovecs, total_size);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>iovec 是 Linux/Unix 系统编程中定义的一个<strong>C 语言结构体</strong>（定义在 &lt;sys/uio.h&gt; 中），专门用于 <strong>Scatter-Gather I/O（分散/聚集 输入输出）</strong></p><p>可以创建一个iovec数组 然后交给系统写入<br> 能够避免字符串片段拼接的重新melloc和cpy的额外开销 而是让系统直接寻找分散的片段 分别写入</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> iovec {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">iov_base;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 指向数据的起始地址（指针）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> iov_len;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 这块数据的长度</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">writev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fd_num</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> iovecs.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> static_cast</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;int&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> iovecs.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> )</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> )</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 最后使用这个系统调用 将iovec的内容写入</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整个类的设计是在内部封装了一个RAII的fd类 保证了资源的释放<br> 外部类持有一个shared_ptr 但是删除了拷贝函数 添加了duplicate方法 这种实现要求显示地声明复制操作 delete掉隐式的拷贝<br> 因为在常规思维中 假设我们编写了传值（fd）的函数，我们认为在函数中操作的都是“副本” 但是实际上这里会影响到fd本身 所以禁用隐式拷贝 强行让程序员调用这一方法 能够避免这一错误——实际上这个实现应该类似直接用unique_ptr管理fdwrapper 但是我们留有一个方法 让他在需要的时候可以复制</p><h1 id="lab5-network-interface-链路层" tabindex="-1"><a class="header-anchor" href="#lab5-network-interface-链路层"><span>Lab5 Network Interface 链路层</span></a></h1><p>这就好比你要寄一个包裹去北京（IP: 北京）：<br> 你不能直接把包裹扔出窗外指望它飞到北京。你必须把包裹交给<strong>快递员（下一跳）</strong>。</p><ol><li><strong>第一跳（你的电脑 -&gt; 路由器）：</strong><ul><li>你的 TCP/IP 栈查看路由表，发现百度不在局域网，必须交给<strong>默认网关（路由器）</strong>。</li><li>于是，你把“给百度的 IP 包”装进一个信封（以太网帧）。</li><li>信封上写的收件人（MAC）是<strong>路由器的 MAC</strong>，而不是百度的 MAC。</li><li><strong>关键点</strong>：Dst IP = 百度, Dst MAC = 路由器。</li></ul></li><li><strong>第二跳（路由器 -&gt; ISP 网关）：</strong><ul><li>路由器收到信封，拆开一看，MAC 是自己，收下。</li><li>再看里面的 IP，是百度。路由器查路由表，决定发给上一级 ISP。</li><li>路由器重新封装一个信封。</li><li><strong>关键点</strong>：Dst IP = 百度（不变！）, Dst MAC = ISP 网关（变了！）。<br><strong>总结：</strong> 在整个传输过程中，<strong>IP 地址全程不变</strong>（像包裹上的收件地址），但 <strong>MAC 地址在每一跳都会改变</strong>（像是包裹在不同快递员、不同卡车之间交接）。</li></ul></li></ol><ul><li><strong>IP 地址（网络层）是逻辑地址，具有层级性（Hierarchical）。</strong><ul><li>就像现实中的<strong>邮政地址</strong>（国家/省/市/街道/门牌号）。</li><li>它的设计是为了<strong>路由（Routing）</strong>。因为 IP 地址是按子网分配的（比如 Stanford 的 IP 都在 171.64.x.x），路由器只需要看 IP 的前缀就知道往哪个方向送。</li><li>IP 地址决定了<strong>最终目的地</strong>。</li></ul></li><li><strong>MAC 地址（链路层）是物理地址，是扁平的（Flat）。</strong><ul><li>就像人的<strong>身份证号</strong>或者指纹。</li><li>它是烧录在网卡里的，全球唯一，但没有任何地理位置信息。如果你知道一个 MAC 地址是 00:1A:2B:3C:4D:5E，你根本不知道它是在北京、纽约，还是就在你隔壁房间。</li><li>MAC 地址决定了<strong>在当前这一根网线上，谁接收数据</strong>。</li></ul></li></ul><h2 id="为什么不全部使用mac" tabindex="-1"><a class="header-anchor" href="#为什么不全部使用mac"><span>为什么不全部使用MAC</span></a></h2><p><strong>MAC 地址不可路由。</strong></p><ul><li><strong>路由表爆炸</strong>：如果不使用分层的 IP 地址，路由器需要记录全球几十亿个设备的 MAC 地址分别在哪个方向。这需要无限大的内存和无法想象的查找时间。</li><li><strong>IP 的作用</strong>：IP 把几十亿台设备聚合成了几十万个“网络段”。路由器只需要记住“往 171.64 开头的 IP 走左边”即可，不需要记住里面的每一台电脑。</li></ul><blockquote><p><strong>IP 是导航仪，MAC 是方向盘。</strong> 你心里知道要去哪里（IP），但在每一刻，你只能控制车轮怎么转（MAC）</p></blockquote><p>在 CS144 的 Lab 5 中，我们需要实现 NetworkInterface。乍一看，它只是一个收发数据包的类，但从系统设计的角度看，它是<strong>逻辑世界（IP 协议）</strong> 与 <strong>物理世界（以太网）</strong> 之间的通用翻译官。</p><ul><li><p><strong>向上（IP 层）</strong>：它面对的是全球互联网。在这里，它只关心“我要把包裹发给 IP 为 192.168.1.1 的下一跳”。</p></li><li><p><strong>向下（链路层）</strong>：它面对的是冰冷的物理线缆。在这里，没有 IP，只有 MAC 地址和电信号。</p></li></ul><p><strong>在链路层面前，众生平等。</strong><br> 无论是一台几十万的高端核心路由器，还是我手里的一部 iPhone，亦或是 CS144 Lab 中的虚拟主机，它们在接入网线的那一端时，运行的都是<strong>完全相同</strong>的 NetworkInterface 代码：</p><ul><li>它们都需要维护 ARP 表。</li><li>它们都需要响应 ARP 请求。</li><li>它们都需要将 IP 包封装进 Ethernet Frame。</li></ul><p><strong>唯一的区别在于：</strong></p><ul><li><p><strong>我的电脑</strong>通常只实例化了一个 NetworkInterface 对象（网卡）。</p></li><li><p><strong>路由器</strong>实例化了多个 NetworkInterface 对象，并在它们之上运行了一个路由算法（Lab 6 的内容），决定将数据从“接口 A”搬运到“接口 B”</p></li></ul><h2 id="两种数据包" tabindex="-1"><a class="header-anchor" href="#两种数据包"><span>两种数据包</span></a></h2><h3 id="第一种包-arp-包-type-arp" tabindex="-1"><a class="header-anchor" href="#第一种包-arp-包-type-arp"><span>第一种包：ARP 包 (Type = ARP)</span></a></h3><p><strong>结构</strong>：[Ethernet Header] + [ARP Message]</p><ol><li><strong>MAC 层检查</strong>： <ul><li>网卡看到以太网头里的 Dst MAC 是 FF:FF:FF:FF:FF:FF（广播）或者 My MAC。</li><li><strong>决定</strong>：收下。</li></ul></li><li><strong>分流</strong>： <ul><li>看 Type 是 ARP，于是把后面那坨数据解析为 ARPMessage。</li></ul></li><li><strong>ARP 层检查（逻辑层）</strong>： <ul><li>看 ARPMessage 里的 Target IP。</li><li><strong>判断</strong>：是我的 IP 吗？</li><li><strong>动作</strong>：如果是，就回信（Reply）；不管是不是，都偷看一眼 Sender IP/MAC 记在小本本上（Snooping）。</li></ul></li></ol><hr><h3 id="第二种包-ipv4-数据包-type-ipv4" tabindex="-1"><a class="header-anchor" href="#第二种包-ipv4-数据包-type-ipv4"><span>第二种包：IPv4 数据包 (Type = IPv4)</span></a></h3><p><strong>结构</strong>：[Ethernet Header] + [IPv4 Datagram]</p><ol><li><strong>MAC 层检查</strong>： <ul><li>网卡看到以太网头里的 Dst MAC 是 My MAC（通常 IPv4 数据包是单播的）。</li><li><strong>决定</strong>：收下。</li></ul></li><li><strong>分流</strong>： <ul><li>看 Type 是 IPv4，于是把后面那坨数据当作 InternetDatagram。</li></ul></li><li><strong>IP 层检查</strong>： <ul><li><strong>NetworkInterface 的工作到此为止</strong>。它直接把这个包放入 datagrams_received_ 队列。</li><li><strong>后续</strong>：上层的 TCPReceiver 或 Router 拿走这个包，才会去检查里面的 Dst IP 是不是自己。</li></ul></li></ol><ul><li><p><strong>ARP 包</strong>：</p><ul><li><strong>信封（Ethernet Header）</strong>：写着“给所有人（广播）”或者“给张三”。标签是<strong>红色</strong>（Type=ARP）。</li><li><strong>信纸（Payload）</strong>：上面写着“寻人启事：谁是 192.168.1.1？”</li></ul></li><li><p><strong>IPv4 包</strong>：</p><ul><li><strong>信封（Ethernet Header）</strong>：写着“给张三”。标签是<strong>蓝色</strong>（Type=IPv4）。</li><li><strong>信纸（Payload）</strong>：上面写着“你好，这是 TCP 握手数据...”。</li></ul></li><li><p><strong>路由表（IP 层）</strong>：建立了 <strong>最终目的地 IP -&gt; 下一跳 IP</strong> 的映射。</p><ul><li>“要去美国，先找上海。”</li></ul></li><li><p><strong>ARP 表（链路层）</strong>：建立了 <strong>下一跳 IP -&gt; 下一跳 MAC</strong> 的映射。</p><ul><li>“要找上海，请去坐标 (X, Y)。”</li></ul></li></ul><p><strong>缺失任何一步都无法通信：</strong></p><ul><li>没有 IP 路由：你不知道该把包给谁（不知道该去上海）。</li><li>没有 ARP 链路：你知道该给谁，但你不知道怎么通过网线接触到他（不知道上海在哪）。</li></ul><h2 id="网络层级" tabindex="-1"><a class="header-anchor" href="#网络层级"><span>网络层级</span></a></h2><ol><li><strong>老板 (应用层/ByteStream)</strong>： <ul><li>写好信的内容：“Hello World”。</li></ul></li><li><strong>秘书 (TCP Sender - Lab 3)</strong>： <ul><li><strong>职责</strong>：负责把信切分成几页，并在每页上标号（Seqno），如果对方没收到就重寄。</li><li><strong>产物</strong>：<strong>TCP Segment</strong>。</li><li><strong>心态</strong>：“我不管这封信怎么送，我只关心对方秘书有没有确认收到。”</li></ul></li><li><strong>收发室 (IP 层)</strong>： <ul><li><strong>职责</strong>：把秘书给的信装进一个写着“最终地址：北京”的信封。</li><li><strong>产物</strong>：<strong>IP Datagram</strong>。</li><li><strong>心态</strong>：“我负责导航，但我自己不开车。”</li></ul></li><li><strong>卡车司机 (NetworkInterface - Lab 5)</strong>： <ul><li><strong>职责</strong>：拿到收发室的信封。但他不认识去北京的路，他只知道第一站要先送到“村口的集散中心（下一跳）”。</li><li>他会问（ARP）：“谁是集散中心？哦，是那辆红色的车（MAC地址）。”</li><li>于是他把信封放进一个大箱子（以太网帧），箱子上写着“给红车”。</li><li><strong>产物</strong>：<strong>Ethernet Frame</strong>。</li><li><strong>心态</strong>：“我不管里面装的是信还是砖头，也不管它最终要去北京还是上海，我只负责把它安全地交给前面那辆车。”<br> 所以说在“秘书”眼里 他正在面对面和对面的秘书对话 虽然这些话语可能是有重复、丢失的。但是我的秘书可以把他们排列好 秘书不关心是怎么和对面连接的</li></ul></li></ol><p><strong>秘书（TCP）</strong> 实际上是在为老板（应用层）制造一种<strong>幻觉</strong></p><ul><li><strong>老板以为</strong>：他和对面的合作伙伴之间有一根专属的管道，他把字条塞进去，对方马上就按顺序拿到了。</li><li><strong>实际情况</strong>：字条被塞进了脏兮兮的卡车（NetworkInterface），卡车要在泥泞的道路上颠簸，中间可能翻车（丢包），可能走错路（乱序），甚至卡车可能被劫持。<br> “秘书不关心是怎么和对面连接的”，这对应了一个非常高级的特性：<strong>介质无关性（Media Independence）</strong>。<br> TCP 代码里没有任何一行是关于“光纤”、“WiFi”或者“以太网”的。它只认 <strong>IP 地址</strong>。只要底层能把那个 IP 包送过去，哪怕是用信鸽送过去的（RFC 1149 鸟类传输协议），TCP 都能照常工作。<br><strong>这就像：</strong><br> 两个秘书坐在一个<strong>无限长、但是会抖动的桌子</strong>两端</li><li>秘书 A 把文件滑过去。</li><li>桌子可能会吞掉文件（丢包），可能会把先滑的挡在后滑的后面（乱序）。</li><li>但是秘书 A 眼里<strong>只有</strong>桌子对面的秘书 B。他不会去想桌子底下是不是有几千个工人在搬运，他只关心：“B，你收到第 5 页了吗？”</li></ul><h1 id="lab6-router" tabindex="-1"><a class="header-anchor" href="#lab6-router"><span>Lab6 Router</span></a></h1><p>只有两个方法<br> 一个是向路由表中添加项<br> 一个是进行路由</p><ul><li>遍历所有接口 收到的ipv4 数据包</li><li>包头中有目的地</li><li>通过路由表进行前缀匹配 （越长越好） 最坏的情况是匹配到了默认路由（匹配长度 == 0 ，一定能发过去）</li><li>向匹配到的路由对应的next hop IP （如果为空的话 代表在同一个局域网内 就不需要路由了 直接发送包头中的dst IP作为下一跳 直接找到） 通过对应的interface（都在路由表中记录） 发送这个数据包</li></ul></div><!----><!----><!----></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/yedou37/yedou37.github.io/edit/main/src/courses/CS144.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">最近更新: </span><time class="vp-meta-info" datetime="2026-02-13T06:35:50.000Z" data-allow-mismatch>2026/2/13 06:35</time></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 137401103+yedou37@users.noreply.github.com">yedou37</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/courses/15445.html" aria-label="CMU-15445 数据库"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->CMU-15445 数据库</div></a><a class="route-link auto-link next" href="/courses/6.5840.html" aria-label="MIT 6.5840 分布式系统"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">MIT 6.5840 分布式系统<iconify-icon class="vp-icon" icon="fa6-solid:hubspot" sizing="height" height="1em"></iconify-icon></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">记录面试复习 & 课程大作业</div><div class="vp-copyright">Copyright © 2026 yedou </div></footer></div><!--]--><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-Co1y7IU-.js" defer></script>
  </body>
</html>
