import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as n,o as t}from"./app-DErs339O.js";const l={};function e(p,s){return t(),a("div",null,[...s[0]||(s[0]=[n(`<hr><h1 id="thread-local-关键字" tabindex="-1"><a class="header-anchor" href="#thread-local-关键字"><span>thread_local 关键字</span></a></h1><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">cosnt</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> StringViewRange</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> buffers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> thread_local</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::vector</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">iovec</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> iovecs;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	// buffer -&gt; iovecs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(iovecs, total_size);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>[线程 A 的内存视角]</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>| 寄存器 fs           | ---&gt; 指向 TLS 区域</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>| TLS 区域 (Thread Local Storage)</span></span>
<span class="line"><span>| [ iovecs_A (24字节) ] --------+</span></span>
<span class="line"><span>+---------------------+         | 指针指向</span></span>
<span class="line"><span>                                v</span></span>
<span class="line"><span>                      +--------------------------+</span></span>
<span class="line"><span>                      | 堆 (Heap)                |</span></span>
<span class="line"><span>                      | [ iovec, iovec, ... ]    | &lt;--- 这里的内存被反复利用</span></span>
<span class="line"><span>                      +--------------------------+</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-------------------------------------------------------</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[线程 B 的内存视角]</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>| 寄存器 fs           | ---&gt; 指向 线程 B 自己的 TLS</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>| TLS 区域</span></span>
<span class="line"><span>| [ iovecs_B (24字节) ] --------+</span></span>
<span class="line"><span>+---------------------+         | 指针指向不同的堆地址</span></span>
<span class="line"><span>                                v</span></span>
<span class="line"><span>                      +--------------------------+</span></span>
<span class="line"><span>                      | 堆 (Heap)                |</span></span>
<span class="line"><span>                      | [ iovec, iovec, ... ]    |</span></span>
<span class="line"><span>                      +--------------------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>类（Class）没有线程，只有操作系统（OS）有线程。</strong></p><ul><li><p><strong>错误理解</strong>：每一个 FileDescriptor 对象都有一个线程</p></li><li><p><strong>正确理解</strong>：你的程序可能启动了 10 个线程，这 10 个线程可能会操作同一个 FileDescriptor 对象，也可能操作 1000 个不同的 FileDescriptor 对象。<br><strong>static thread_local 的含义是：</strong><br> 不管你创建了多少个 FileDescriptor 对象（哪怕 1 万个），<strong>只要它们是在同一个线程（Thread A）里运行的 write 函数，它们就共享同一个 iovecs 变量。</strong></p></li><li><p><strong>场景 1</strong>：线程 A 里的 socket1 调了 write，接着 socket2 也调了 write。</p><ul><li>结果：socket2 会<strong>复用</strong> socket1 刚刚用过的那块内存（前提是 socket1 用完后 vector 被 clear 了，但 capacity 还在）。效率极高！</li></ul></li><li><p><strong>场景 2</strong>：线程 A 里的 socket1 和线程 B 里的 socket1 同时调 write。</p><ul><li>结果：线程 A 用的是 iovecs_A，线程 B 用的是 iovecs_B。互不干扰，不需要加锁。</li></ul></li><li><p><strong>出生（构造）</strong>：</p><ul><li>当<strong>某个线程第一次</strong>运行到 write 函数内部的那一行代码时，这个线程专属的 iovecs 被构造。</li><li>如果你有 10 个线程，但只有 3 个线程调用过 write，那就只有 3 个 iovecs 被创建。</li></ul></li><li><p><strong>存活</strong>：</p><ul><li>只要这个<strong>线程</strong>还活着，这个变量就一直活着（保留着堆内存）。</li><li>它<strong>不随对象的销毁而销毁</strong>。即使你把所有的 FileDescriptor 对象都析构了，只要线程还在，这个 iovecs 依然占着内存等待下一次召唤。</li></ul></li><li><p><strong>死亡（析构）</strong>：</p><ul><li>当<strong>线程退出（Thread Exit）</strong> 时。</li><li>C++ 运行时环境会自动遍历该线程所有的 thread_local 变量，调用它们的析构函数，从而释放那块堆内存，最后清理 TLS 里的头信息。</li></ul></li></ul><h3 id="static-是什么意思-在函数内部" tabindex="-1"><a class="header-anchor" href="#static-是什么意思-在函数内部"><span>static 是什么意思？（在函数内部）</span></a></h3><p>当 static 用于函数内部的局部变量时，它改变的是变量的 <strong>生命周期（Lifecycle）</strong> 和 <strong>存储位置</strong>。</p><ul><li><strong>普通局部变量</strong> (int a = 0;) <ul><li><strong>存储位置</strong>：栈（Stack）。</li><li><strong>生命周期</strong>：函数被调用时创建，函数返回时销毁。下次调用时是全新的。</li><li><strong>比喻</strong>：便利贴。用完就撕了扔掉。</li></ul></li><li><strong>静态局部变量</strong> (static int a = 0;)： <ul><li><strong>存储位置</strong>：数据段（Data Segment / BSS）。</li><li><strong>生命周期</strong>：<strong>整个程序运行期间</strong>。它在程序第一次运行到这行代码时初始化，直到程序结束才销毁。</li><li><strong>比喻</strong>：墙上的白板。你写了字，离开房间再回来，字还在那里。</li></ul></li></ul><hr><h3 id="thread-local-是什么意思" tabindex="-1"><a class="header-anchor" href="#thread-local-是什么意思"><span>thread_local 是什么意思？</span></a></h3><p>它改变的是变量的 <strong>实例数量</strong> 和 <strong>归属权</strong>。</p><ul><li><strong>没有 thread_local</strong>： <ul><li>全局只有一份（如果是 static）。所有线程看到的都是同一个变量，改的也是同一个。</li><li><strong>后果</strong>：多线程同时改会打架（Data Race），必须加锁。</li></ul></li><li><strong>有 thread_local</strong>： <ul><li>每个线程都有一份独立的拷贝。</li><li><strong>生命周期</strong>：<strong>与线程绑定</strong>。线程启动（或第一次使用）时创建，线程结束时销毁。</li></ul></li></ul><hr><h1 id="std-unique-ptr-std-make-unique" tabindex="-1"><a class="header-anchor" href="#std-unique-ptr-std-make-unique"><span><code>std::unique_ptr&lt;&gt; std::make_unique&lt;&gt;()</code></span></a></h1><ol><li><strong><code>std::unique_ptr</code> (霸道总裁)</strong>： <ul><li>它是<strong>管理者</strong>。</li><li>它的座右铭是：“<strong>这块内存是我的，只能是我的，谁也别想复制，但我死了这块内存也别想活。</strong>”</li><li>它通过 RAII（资源获取即初始化）机制，保证出了作用域自动释放内存。</li></ul></li><li><strong><code>std::make_unique</code> (专属工厂)</strong>： <ul><li>它是<strong>生产者</strong>。</li><li>它的作用是：“<strong>别自己瞎折腾去 new 了，把要求告诉我，我帮你造好打包送给你。</strong>”</li><li>它是 C++14 引入的辅助函数，用来生成 <code>unique_ptr</code>。<br> 独占所有权-&gt;不能拷贝 只能移动<br> 零开销</li></ul></li></ol><ul><li>unique_ptr 内部只存了一个裸指针。</li><li>如果你不使用自定义删除器（Deleter），它的大小和 int* 完全一样（64位系统下就是 8 字节）。</li><li>它的解引用操作 *ptr 和 ptr-&gt; 会被编译器优化成和裸指针一模一样的汇编指令</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">process</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()), std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>C++ 编译器在编译这行代码时，执行顺序是不确定的（Unspecified Evaluation Order）。它可能这样执行：</p><ol><li>new A() 分配成功。</li><li><strong>执行 new B() —— 此时内存不足抛出异常！</strong></li><li><code>std::unique_ptr&lt;A&gt;</code> 的构造函数还没来得及执行。</li><li><strong>结果</strong>：A 的指针丢失了，没人负责 delete 它，<strong>内存泄漏</strong>。</li></ol><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">process</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">make_unique</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(), std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">make_unique</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>make_unique 内部封装了 new 和 unique_ptr 的构造。它是一个完整的函数调用。<br> 这意味着步骤变成了：</p><ol><li>完整执行 <code>make_unique&lt;A&gt;()</code>（分配+包装）。成功后返回一个对象。</li><li>完整执行 <code>make_unique&lt;B&gt;()</code>。</li><li><strong>如果 B 失败了，A 已经是一个智能指针对象了，它会自动析构释放内存。</strong></li><li><strong>结论：零泄漏风险。</strong></li></ol><h1 id="使用工厂函数" tabindex="-1"><a class="header-anchor" href="#使用工厂函数"><span>使用工厂函数</span></a></h1><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 方式1：不使用工厂函数（复杂）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TypeId</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int32_t</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">type_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(type), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">value_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(value) {}</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TypeId</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">type_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(type) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 复杂的字符串处理逻辑</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 内存管理逻辑</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TypeId</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">type_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(type), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">value_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#ABB2BF;">static_cast</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;int8_t&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(value)) {}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 使用时需要记住复杂的构造方式</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> int_val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(TypeId::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">INTEGER</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> bool_val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(TypeId::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BOOLEAN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">static_cast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int8_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 需要手动转换</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 方式2：使用工厂函数（简洁）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ValueFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> inline</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetIntegerValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int32_t</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {TypeId::INTEGER, value};</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> inline</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetBooleanValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {TypeId::BOOLEAN, </span><span style="--shiki-light:#A626A4;--shiki-dark:#ABB2BF;">static_cast</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;int8_t&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(value)};</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 使用时非常简单直观</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Value int_val </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ValueFactory::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetIntegerValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Value bool_val </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ValueFactory::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetBooleanValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工厂函数一般都使用static 因为这样函数只属于这个工厂类本身 不需要实例化一个ValueFactory对象 能够直接通过这个类名进行调用 而且可以在全局范围内进行访问<br> 优点</p><ul><li>能够统一接口</li><li>易于扩展 如果需要支持新的类别的话 直接在工厂中添加新方法即可</li><li>隐藏复杂度</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">protected:</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">type_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(type), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">x_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">y_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(y) {}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreatePlayer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> player </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;player&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, x, y));</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        player</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setHealth</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        player</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setSpeed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> player;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreateEnemy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> enemy </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;enemy&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, x, y));</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        enemy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setHealth</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        enemy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setSpeed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        enemy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setAggressive</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> enemy;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreateItem</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> itemType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> item </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;item&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, x, y));</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        item</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setItemProperties</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(itemType);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> item;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 使用</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> player </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> GameObject::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreatePlayer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> enemy </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> GameObject::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreateEnemy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> potion </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> GameObject::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreateItem</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;health_potion&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如这里都是创建游戏中的对象 可以使用工厂函数 更加简单直观地进行构造</p><h1 id="top-k" tabindex="-1"><a class="header-anchor" href="#top-k"><span>TOP-K</span></a></h1><hr><h3 id="_1-场景一-单机内存处理-static-data-fit-in-memory" tabindex="-1"><a class="header-anchor" href="#_1-场景一-单机内存处理-static-data-fit-in-memory"><span>1. 场景一：单机内存处理（Static Data, Fit in Memory）</span></a></h3><p>假设给你一个包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个整数的数组，内存放得下，找出最大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 个。</p><h4 id="方法-a-全量排序-naive-approach" tabindex="-1"><a class="header-anchor" href="#方法-a-全量排序-naive-approach"><span>方法 A：全量排序 (Naive Approach)</span></a></h4><ul><li><strong>做法</strong>：使用 <code>std::sort</code> (QuickSort/MergeSort) 将数组完全排序，然后取前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 个。</li><li><strong>复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li><li><strong>评价</strong>：<strong>最差</strong>。当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 很大而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 很小时（例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>1000</mn><mtext>万</mtext><mo separator="true">,</mo><mi>K</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">N=1000万, K=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">1000</span><span class="mord cjk_fallback">万</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>），做了大量无用功。</li></ul><h4 id="方法-b-最小堆-min-heap-——-工程首选" tabindex="-1"><a class="header-anchor" href="#方法-b-最小堆-min-heap-——-工程首选"><span>方法 B：最小堆 (Min-Heap) —— <strong>工程首选</strong></span></a></h4><ul><li><strong>做法</strong>： <ol><li>维护一个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 的<strong>小顶堆</strong>。</li><li>遍历数组，将元素压入堆。</li><li>如果堆的大小超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>，弹出堆顶（即堆中最小的元素，也就是当前 Top K 里最弱的那个）。</li><li>最终堆里剩下的就是最大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 个。</li></ol></li><li><strong>复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \\log K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>。</li><li><strong>评价</strong>：<strong>最通用、最稳健</strong>。特别是当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>≪</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">K \\ll N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 时，效率极高。你优化后的代码用的就是这个。</li></ul><h4 id="方法-c-快速选择-quick-select-——-平均最快" tabindex="-1"><a class="header-anchor" href="#方法-c-快速选择-quick-select-——-平均最快"><span>方法 C：快速选择 (Quick Select) —— <strong>平均最快</strong></span></a></h4><ul><li><strong>做法</strong>：基于快速排序（Quick Sort）的 Partition 思想。 <ol><li>随机选一个 Pivot，将数组分为“比 Pivot 大”和“比 Pivot 小”两部分。</li><li>看 Pivot 的位置： <ul><li>如果 Pivot 正好在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 个位置，那么它左边的就是 Top K。</li><li>如果 Pivot 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 之后，递归处理左边。</li><li>如果 Pivot 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 之前，递归处理右边。</li></ul></li></ol></li><li><strong>复杂度</strong>：平均 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，最坏 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li><li><strong>评价</strong>：<strong>理论最快</strong>，但修改了原数组，且不稳定。C++ 标准库中有 <code>std::nth_element</code> 就是这个实现。</li></ul><hr><h3 id="_2-场景二-海量数据-流式数据-streaming-data" tabindex="-1"><a class="header-anchor" href="#_2-场景二-海量数据-流式数据-streaming-data"><span>2. 场景二：海量数据/流式数据（Streaming Data）</span></a></h3><p>假设数据是实时流进来的（像网络包、日志），或者数据在磁盘上，内存放不下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个元素。</p><ul><li><strong>限制</strong>：无法将所有数据加载到内存，无法使用 Quick Select。</li><li><strong>唯一解法：最小堆 (Min-Heap)</strong>。 <ul><li><strong>原理</strong>：不管 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 有多大（1TB 甚至无穷大），内存中只需要维护一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 大小的堆。</li><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>。</li></ul></li><li><strong>应用</strong>：实时热搜榜、DDOS 攻击检测（流量最大的 K 个 IP）。</li></ul><hr><h3 id="_3-场景三-分布式大数据-distributed-big-data" tabindex="-1"><a class="header-anchor" href="#_3-场景三-分布式大数据-distributed-big-data"><span>3. 场景三：分布式大数据（Distributed / Big Data）</span></a></h3><p>假设有 10 亿行数据，分布在 1000 台机器上，要找全局 Top-K。</p><ul><li><strong>限制</strong>：单机算不动，网络带宽有限。</li><li><strong>解法：分治法 (MapReduce 思想)</strong><ol><li><strong>Map 阶段</strong>：每台机器在本地数据上计算<strong>局部 Top-K</strong>（使用堆）。</li><li><strong>Reduce 阶段</strong>：每台机器将这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 个元素发送给一台中心机器（或者下一层聚合节点）。</li><li><strong>Merge 阶段</strong>：中心机器收集到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn><mo>×</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">1000 \\times K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1000</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 个元素，再做一次 Top-K，得到全局 Top-K。</li></ol></li><li><strong>关键点</strong>：传输的数据量非常小（只有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>），而不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。</li></ul><hr><h3 id="_4-场景四-统计-频率-最高的-top-k-heavy-hitters" tabindex="-1"><a class="header-anchor" href="#_4-场景四-统计-频率-最高的-top-k-heavy-hitters"><span>4. 场景四：统计“频率”最高的 Top-K (Heavy Hitters)</span></a></h3><p>上面的场景都是基于元素的值（Value）排序。如果问题是：<strong>“在一个 100GB 的日志文件中，找出出现次数最多的 10 个 IP 地址”</strong>。</p><p>这是一个难点，因为你不仅要排序，还要先<strong>统计计数</strong>。</p><h4 id="方法-a-hash-map-heap-精确解" tabindex="-1"><a class="header-anchor" href="#方法-a-hash-map-heap-精确解"><span>方法 A：Hash Map + Heap (精确解)</span></a></h4><ul><li><strong>做法</strong>：用 Hash Map 统计所有 IP 的出现次数，然后把 (IP, Count) 扔进堆里求 Top-K。</li><li><strong>缺点</strong>：如果有 10 亿个不同的 IP，Hash Map 内存会爆炸。</li></ul><h4 id="方法-b-hash-分片-精确解-分布式" tabindex="-1"><a class="header-anchor" href="#方法-b-hash-分片-精确解-分布式"><span>方法 B：Hash 分片 (精确解，分布式)</span></a></h4><ul><li><strong>做法</strong>： <ol><li>把 IP 按照 <code>hash(IP) % 1024</code> 分发到 1024 个小文件中。</li><li>这样相同的 IP 肯定在同一个文件里。</li><li>分别加载每个小文件到内存，用 Hash Map 统计并求局部 Top-K。</li><li>最后归并。</li></ol></li></ul><h4 id="方法-c-count-min-sketch-misra-gries-近似解" tabindex="-1"><a class="header-anchor" href="#方法-c-count-min-sketch-misra-gries-近似解"><span>方法 C：Count-Min Sketch / Misra-Gries (近似解)</span></a></h4><ul><li><strong>场景</strong>：允许一点点误差，但必须极省内存（比如路由器硬件）。</li><li><strong>做法</strong>：使用概率数据结构（如 Count-Min Sketch）。 <ul><li>用多个 Hash 函数将元素映射到二维数组中进行计数。</li><li>不需要存储 IP 本身，只存储计数值。</li><li><strong>优点</strong>：用极小的空间（几KB）就能统计海量数据。</li></ul></li></ul><hr><h3 id="_5-数据库中的-top-k-优化" tabindex="-1"><a class="header-anchor" href="#_5-数据库中的-top-k-优化"><span>5. 数据库中的 Top-K 优化</span></a></h3><p><code>SELECT * FROM table ORDER BY col LIMIT K</code>。</p><p>数据库优化器通常会按以下顺序尝试：</p><ol><li><p><strong>利用索引 (Index Scan)</strong>：</p><ul><li>如果在 <code>col</code> 上有 B+ 树索引，索引本身就是有序的。</li><li>数据库只需要读索引的最左边（或最右边）的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 个条目。</li><li><strong>复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>。这是极速模式。</li></ul></li><li><p>**Top-N Heap Sort：</p><ul><li>如果没索引，必须全表扫描。</li><li>在扫描过程中维护一个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 的堆。</li><li><strong>复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \\log K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>。</li></ul></li><li><p><strong>全量排序 (External Sort)</strong>：</p><ul><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 非常大（比如 <code>LIMIT 1000000</code>），堆太大内存放不下。</li><li>退化为外部归并排序。</li></ul></li></ol><h3 id="总结表" tabindex="-1"><a class="header-anchor" href="#总结表"><span>总结表</span></a></h3><table><thead><tr><th style="text-align:left;">场景</th><th style="text-align:left;">最佳策略</th><th style="text-align:left;">复杂度</th><th style="text-align:left;">备注</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>内存充足，静态数据</strong></td><td style="text-align:left;"><strong>Quick Select</strong></td><td style="text-align:left;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left;">会修改原数组</td></tr><tr><td style="text-align:left;"><strong>内存充足，一般通用</strong></td><td style="text-align:left;"><strong>Min-Heap</strong></td><td style="text-align:left;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \\log K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left;">不改原数组，稳定</td></tr><tr><td style="text-align:left;"><strong>流式数据 (Streaming)</strong></td><td style="text-align:left;"><strong>Min-Heap</strong></td><td style="text-align:left;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \\log K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span></td><td style="text-align:left;">空间仅需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:left;"><strong>海量数据 (分布式)</strong></td><td style="text-align:left;"><strong>分治 + 归并</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">MapReduce 经典案例</td></tr><tr><td style="text-align:left;"><strong>高频词统计 (精确)</strong></td><td style="text-align:left;"><strong>Hash分片 + Heap</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">解决 Map 内存爆炸问题</td></tr><tr><td style="text-align:left;"><strong>高频词统计 (近似)</strong></td><td style="text-align:left;"><strong>Count-Min Sketch</strong></td><td style="text-align:left;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 空间</td><td style="text-align:left;">牺牲精度换空间</td></tr></tbody></table><h1 id="顶层const-与底层const" tabindex="-1"><a class="header-anchor" href="#顶层const-与底层const"><span>顶层const 与底层const</span></a></h1><h3 id="_1-基本定义" tabindex="-1"><a class="header-anchor" href="#_1-基本定义"><span>1. 基本定义</span></a></h3><h4 id="顶层-const-top-level-const" tabindex="-1"><a class="header-anchor" href="#顶层-const-top-level-const"><span>顶层 const (Top-level const)</span></a></h4><p><strong>顶层 const 表示对象本身是一个常量。</strong> 一旦初始化，该变量的值就不能再改变。</p><ul><li>适用于任何对象类型（如 <code>int</code>、<code>double</code>、类对象、指针本身等）。</li></ul><h4 id="底层-const-low-level-const" tabindex="-1"><a class="header-anchor" href="#底层-const-low-level-const"><span>底层 const (Low-level const)</span></a></h4><p><strong>底层 const 与指针和引用等复合类型有关。</strong> 它表示<strong>所指的对象是一个常量</strong>，但变量本身（如果是指针）是可以指向其他地方的。</p><hr><h3 id="_2-指针中的区别-最容易混淆的地方" tabindex="-1"><a class="header-anchor" href="#_2-指针中的区别-最容易混淆的地方"><span>2. 指针中的区别（最容易混淆的地方）</span></a></h3><p>指针既可以是顶层 const，也可以是底层 const，或者两者都是。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// --- 顶层 const ---</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int*</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       // p1 是顶层 const。p1 的值（地址）不能变，但可以通过 p1 修改 i。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ci </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ci 是顶层 const。ci 的值不能变。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// --- 底层 const ---</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       // p2 是底层 const。不能通过 p2 修改 i，但 p2 可以指向别处。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> r </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ci;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 所有的引用 const 都是底层 const，因为引用本身不是对象，不可改变绑定。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// --- 两者兼有 ---</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int*</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p3 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p2;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 左边的 const 是底层，右边的 const 是顶层。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                          // p3 既不能指向别处，也不能通过它修改所指的值。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>判断小技巧：</strong><br> 以星号 <code>*</code> 为分界线：</p><ul><li>如果 <code>const</code> 在 <code>*</code> <strong>右边</strong>：是<strong>顶层</strong> const（修饰指针变量本身）。</li><li>如果 <code>const</code> 在 <code>*</code> <strong>左边</strong>：是<strong>底层</strong> const（修饰指针指向的数据）。</li></ul><hr><h3 id="_3-核心区别与影响" tabindex="-1"><a class="header-anchor" href="#_3-核心区别与影响"><span>3. 核心区别与影响</span></a></h3><p>这两者的区别主要体现在<strong>执行拷贝操作</strong>时：</p><h4 id="_1-顶层-const-的拷贝-不受影响" tabindex="-1"><a class="header-anchor" href="#_1-顶层-const-的拷贝-不受影响"><span>(1) 顶层 const 的拷贝：不受影响</span></a></h4><p>当执行拷贝操作时，顶层 const 会被忽略。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ci </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ci;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 正确：ci 是顶层 const，拷贝时忽略它的常量属性。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int*</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p1;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 正确：p1 是顶层 const，拷贝 p1 的值（地址）没问题。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-底层-const-的拷贝-严格限制" tabindex="-1"><a class="header-anchor" href="#_2-底层-const-的拷贝-严格限制"><span>(2) 底层 const 的拷贝：严格限制</span></a></h4><p>当执行拷贝操作时，拷入和拷出的对象必须具有<strong>相同的底层 const 资格</strong>，或者能够进行类型转换（通常是 <strong>非 const 能够转化为 const</strong>，反之不行）。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // p2 是底层 const</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p3 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p2;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          // 错误：p2 有底层 const，而 p3 没有。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                       // 如果允许，你就能通过 p3 修改 p2 本来保护的数据。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p4 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p2;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 正确：两者都是底层 const。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p5 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">p2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p5;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">               // 正确：int* 可以转化为 const int*。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_4-为什么需要区分它们" tabindex="-1"><a class="header-anchor" href="#_4-为什么需要区分它们"><span>4. 为什么需要区分它们？</span></a></h3><ol><li><p><strong>函数模板与 <code>auto</code>：</strong></p><ul><li><code>auto</code> 关键字在推导类型时，通常会<strong>忽略顶层 const</strong>，但会<strong>保留底层 const</strong>。</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ci </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ci;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       // a 是 int（顶层 const 被忽略）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ci;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // b 是 const int*（底层 const 被保留）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>函数重载：</strong></p><ul><li>对于顶层 const，编译器无法区分形参。</li><li>对于底层 const（指针或引用的指向对象是否为 const），编译器可以区分。</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> func</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {}       </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> func</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {}</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 错误：重复定义（顶层 const 不构成重载）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {}      </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {}</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 正确：底层 const 可以构成重载</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>强制类型转换：</strong><br><code>const_cast</code> 只能改变运算对象的<strong>底层 const</strong> 属性。</p></li></ol><h1 id="类型转换符" tabindex="-1"><a class="header-anchor" href="#类型转换符"><span>类型转换符</span></a></h1><ol><li><p><strong>static_cast</strong>：</p><ul><li><p><strong>最常用</strong>。用于良性转换（如 int 转 float，找回存在虚继承关系的父子类指针等）。</p></li><li><p><strong>注意</strong>：它在编译时完成，没有运行时类型检查（对于下行转换是不安全的）。</p></li></ul></li><li><p><strong>dynamic_cast</strong>：</p><ul><li><p>专门用于<strong>含有虚函数的类层次结构</strong>中的安全转换（下行转换）。</p></li><li><p><strong>特点</strong>：在运行时检查。如果转换失败，对于指针返回 nullptr，对于引用抛出异常。</p></li></ul></li><li><p><strong>reinterpret_cast</strong>：</p><ul><li><p>最危险。它进行底层的位模式重新解释（如将一个 int* 强制转为 char*）。</p></li><li><p>没有逻辑转换，只是告诉编译器“把这块内存当成另一种类型看”。</p></li></ul></li><li><p><strong>const_cast</strong>：</p><ul><li><strong>唯一</strong>能去掉或加上 const 或 volatile 属性的转换符。</li></ul></li></ol><h1 id="vptr-vtable-与-多继承情况下的虚函数表" tabindex="-1"><a class="header-anchor" href="#vptr-vtable-与-多继承情况下的虚函数表"><span>vptr vtable 与 多继承情况下的虚函数表</span></a></h1><p>在C++中，运行时多态（Runtime Polymorphism）是通过<strong>虚函数（Virtual Function）</strong>、<strong>虚函数表（vtable）</strong> 和<strong>虚指针（vptr）</strong> 共同实现的。这种机制允许程序在运行时根据对象的实际类型（Dynamic Type）而非声明类型（Static Type）来决定调用哪个函数。</p><hr><h3 id="_1-虚函数表-vtable-多态的地图" tabindex="-1"><a class="header-anchor" href="#_1-虚函数表-vtable-多态的地图"><span>1. 虚函数表 (vtable)：多态的地图</span></a></h3><p><strong>虚函数表</strong>是一个由编译器为每一个<strong>包含虚函数的类</strong>维护的静态数组（通常存储在只读数据段）。</p><ul><li><strong>结构</strong>： <ul><li><p>vtable 本质上是一个<strong>函数指针数组</strong>。</p></li><li><p>数组的每个条目存储着该类虚函数的入口地址。</p></li><li><p>通常，vtable 的头部（索引为 -1 或 -2 的位置）还会包含 <strong>RTTI（运行时类型信息）</strong>，如 <code>type_info</code>，用于 <code>dynamic_cast</code> 和 <code>typeid</code> 的识别。</p><ul><li>在单继承中，对象只有一个 vptr。但在<strong>多重继承</strong>中，为了兼容不同的基类指针，子类对象会有<strong>多个 vptr</strong>。</li></ul><p>Child 对象的内存布局大致如下（64位系统）：</p><ol><li><p><strong>[0-7 字节]</strong>：vptr_Mother（指向 Child 专门为 Mother 准备的虚表）</p></li><li><p><strong>[8-11 字节]</strong>：Mother::m_data</p></li><li><p><strong>[16-23 字节]</strong>：vptr_Father（指向 Child 专门为 Father 准备的虚表）</p></li><li><p><strong>[24-27 字节]</strong>：Father::f_data</p></li><li><p><strong>[28-31 字节]</strong>：Child::c_data</p></li></ol><p><code>Child* c2 = dynamic_cast&lt;Child*&gt;(f);</code><br> 运行时库拿到 f 时，它只知道 f 现在指向的是某个包含 vptr_Father 的内存块。如果它想知道这个对象的<strong>真实完整类型</strong>，它必须找到对象的<strong>最开头</strong>（也就是 Mother 开始的地方），因为只有在那里才能找到 Child 类的完整 RTTI（type_info）。</p></li></ul></li></ul><ul><li><p>解决办法：offset-to-top</p><p>在 vptr_Father 指向的那个虚表中，索引为 <strong>-2</strong> 的位置存了一个值：<strong>-16</strong>。</p><ol><li><p>dynamic_cast 访问 f 指向的 vptr_Father。</p></li><li><p>查阅虚表索引 -2 的位置，发现 offset-to-top 是 -16。</p></li><li><p>它将 f 的地址加上 -16，瞬间<strong>找回了对象的真正头部</strong>。</p></li><li><p>在头部获取 Child 的 type_info，从而确认这个对象确实是一个 Child。<br> 在多重继承下，Child 类实际上拥有一个“组合虚表”，它可以被拆分成多个部分供不同的基类指针使用。</p></li></ol><p>对于 Child : public Mother, public Father：</p><p>A. Mother 对应的虚表部分（主虚表 Primary Vtable）：</p><ul><li><p><strong>索引 -2 (offset-to-top)</strong>: 0 （因为 Mother 在 Child 的最开头，偏移量为 0）。</p></li><li><p><strong>索引 -1 (typeinfo ptr)</strong>: 指向 Child 的 type_info。</p></li><li><p><strong>索引 0, 1...</strong>: Child::cook() 等虚函数地址。</p></li></ul><p>B. Father 对应的虚表部分（次虚表 Secondary Vtable）：</p><ul><li><p><strong>索引 -2 (offset-to-top)</strong>: -16 （告诉程序：如果你想回对象头，请减 16 字节）。</p></li><li><p><strong>索引 -1 (typeinfo ptr)</strong>: <strong>同样指向 Child 的 type_info</strong>。</p></li><li><p><strong>索引 0, 1...</strong>: Child::drive() 等虚函数地址。</p></li></ul><p>为什么都要存 type_info？</p><p>因为编译器无法预知你会从哪个基类指针发起 dynamic_cast。</p><ul><li><p>如果你手持 Mother*，你会通过 Mother 的虚表看到它是 Child。</p></li><li><p>如果你手持 Father*，你会通过 Father 的虚表看到它是 Child。<br> 所以，<strong>所有</strong>关联到这个类的虚表部分，其索引 -1 必须一致指向该类的真实类型信息。</p></li></ul></li></ul><ul><li><strong>生成时机</strong>： <ul><li><strong>编译期</strong>。编译器在编译每个类时，如果发现类中有虚函数，就会为该类生成一个唯一的 vtable。</li></ul></li><li><strong>存储位置</strong>： <ul><li>存储在可执行文件的<strong>只读数据段（.rodata 或 .text）</strong>。它不占用对象的内存空间，而是所有该类的实例共用同一个 vtable。</li></ul></li><li><strong>类层次结构中的关系</strong>： <ul><li><strong>基类</strong>：拥有自己的 vtable，记录其虚函数地址。</li><li><strong>派生类</strong>：也会拥有自己的 vtable。 <ul><li>如果派生类<strong>重写（Override）</strong> 了基类的虚函数，派生类 vtable 中对应的条目会被替换为派生类函数的地址。</li><li>如果派生类<strong>没有重写</strong>，则条目保留基类函数的地址。</li><li>如果派生类<strong>定义了新的虚函数</strong>，这些函数的地址会被追加到 vtable 的末尾。</li></ul></li></ul></li></ul><hr><h3 id="_2-虚指针-vptr-连接对象与地图的桥梁" tabindex="-1"><a class="header-anchor" href="#_2-虚指针-vptr-连接对象与地图的桥梁"><span>2. 虚指针 (vptr)：连接对象与地图的桥梁</span></a></h3><p><strong>虚指针</strong>是编译器隐式添加到对象实例中的一个指针。</p><ul><li><strong>存在方式</strong>： <ul><li>当一个类拥有虚函数时，编译器会为该类的每个对象增加一个隐藏的指针成员（通常命名为 <code>__vptr</code>）。</li><li>为了提高效率，<code>vptr</code> 通常位于对象内存布局的<strong>最前面</strong>（Offset 0）。</li></ul></li><li><strong>初始化过程</strong>： <ul><li><strong>构造函数执行时初始化</strong>。</li><li>当创建一个派生类对象时： <ol><li>首先调用基类构造函数。此时 <code>vptr</code> 指向<strong>基类</strong>的 vtable。</li><li>然后执行派生类构造函数。此时 <code>vptr</code> 被更新，指向<strong>派生类</strong>的 vtable。</li></ol></li><li><em>注意：这也是为什么在构造函数中调用虚函数无法实现多态的原因——此时对象尚未完全构造，<code>vptr</code> 仍指向当前构造层的 vtable。</em></li></ul></li><li><strong>作用</strong>： <ul><li>它是对象实例与类 vtable 之间的纽带。通过 <code>vptr</code>，运行时系统能够找到该对象对应的 vtable，进而找到正确的函数地址。</li></ul></li></ul><hr><h3 id="_3-动态绑定的查找过程-协同工作原理" tabindex="-1"><a class="header-anchor" href="#_3-动态绑定的查找过程-协同工作原理"><span>3. 动态绑定的查找过程：协同工作原理</span></a></h3><p>当执行类似 <code>base_ptr-&gt;virtual_func()</code> 的代码时，编译器并不会生成一个直接跳转到某个函数地址的指令，而是生成一段<strong>查找代码</strong>。</p><h4 id="查找步骤-汇编逻辑" tabindex="-1"><a class="header-anchor" href="#查找步骤-汇编逻辑"><span>查找步骤（汇编逻辑）：</span></a></h4><ol><li><strong>获取 vptr</strong>：程序访问 <code>base_ptr</code> 所指向的对象，取出该对象起始位置存储的 <code>vptr</code>。</li><li><strong>定位 vtable</strong>：通过 <code>vptr</code> 找到该对象所属类的虚函数表（vtable）。</li><li><strong>索引偏移</strong>：编译器在编译阶段已经确定了 <code>virtual_func</code> 在 vtable 中的<strong>偏移量（Index）</strong>。例如，如果 <code>virtual_func</code> 是类中定义的第一个虚函数，那么它就在索引 0 的位置。</li><li><strong>间接跳转</strong>：程序取出 vtable 中对应索引处的函数指针，并跳转到该地址执行。</li></ol><h4 id="为什么能确保正确性" tabindex="-1"><a class="header-anchor" href="#为什么能确保正确性"><span>为什么能确保正确性？</span></a></h4><ul><li><strong>静态与动态的分工</strong>： <ul><li><strong>编译器（静态）</strong>：决定函数在 vtable 中的“槽位”（Index）。无论基类还是派生类，同一个虚函数在 vtable 中的索引是一致的。</li><li><strong>运行时（动态）</strong>：通过 <code>vptr</code> 找到“具体的地图”（vtable）。如果是派生类对象，<code>vptr</code> 指向派生类的表，表里索引 N 的位置存放的是派生类重写后的地址。</li></ul></li><li><strong>实例独立性</strong>：每个对象实例都有独立的内存空间。即使是两个不同的派生类对象（例如 <code>Dog</code> 和 <code>Cat</code> 都继承自 <code>Animal</code>），它们各自的 <code>vptr</code> 会分别指向 <code>Dog::vtable</code> 和 <code>Cat::vtable</code>。</li></ul><h3 id="总结图示" tabindex="-1"><a class="header-anchor" href="#总结图示"><span>总结图示</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>对象内存布局 (Derived object)      派生类虚函数表 (Derived vtable)</span></span>
<span class="line"><span>+-----------------------+        +--------------------------+</span></span>
<span class="line"><span>| vptr (指向 vtable) ----|------&gt; | [0]: RTTI / type_info     |</span></span>
<span class="line"><span>+-----------------------+        +--------------------------+</span></span>
<span class="line"><span>| 成员变量 A             |        | [1]: Derived::func1()    | (重写了基类)</span></span>
<span class="line"><span>+-----------------------+        +--------------------------+</span></span>
<span class="line"><span>| 成员变量 B             |        | [2]: Base::func2()       | (继承自基类)</span></span>
<span class="line"><span>+-----------------------+        +--------------------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>结论</strong>：C++ 的多态性是以<strong>空间换时间</strong>的策略。它增加了一个指针的内存开销（vptr）和一张表（vtable）的存储开销，并通过两次解引用（一次找 vtable，一次找函数）的微小时间代价，实现了强大的运行时灵活性。</p><h1 id="rtti" tabindex="-1"><a class="header-anchor" href="#rtti"><span>RTTI</span></a></h1><p>简单一句话：<strong>RTTI 是一套由编译器生成的“类描述信息”结构体，它是一个实实在在存在的只读数据，存储在可执行文件的只读数据段（.rodata）中。</strong></p><p>下面是详细的拆解：</p><hr><h3 id="_1-rtti-是什么-是一个额外的结构吗" tabindex="-1"><a class="header-anchor" href="#_1-rtti-是什么-是一个额外的结构吗"><span>1. RTTI 是什么？是一个额外的结构吗？</span></a></h3><p><strong>是的，它是一组结构体。</strong></p><p>虽然 C++ 标准只规定了 <code>std::type_info</code> 类，但各大编译器（如 GCC/Clang 使用的 Itanium ABI）为了实现 <code>dynamic_cast</code> 在复杂的继承树里“导航”，实现了一套非常详细的结构体层次：</p><ul><li><strong><code>__class_type_info</code></strong>：最基础的类，不包含继承关系。</li><li><strong><code>__si_class_type_info</code></strong>：单继承类的 RTTI。它里面包含一个指向基类 RTTI 的指针。</li><li><strong><code>__vmi_class_type_info</code></strong>（Virtual Multiple Inheritance）：最复杂的。它记录了： <ul><li>有多少个基类。</li><li>每个基类的 RTTI 指针。</li><li>每个基类相对于子类头部的<strong>偏移量</strong>。</li><li>基类是 <code>public</code> 还是 <code>private</code> 继承，是否是 <code>virtual</code> 继承。</li></ul></li></ul><p><strong>这就是为什么 <code>dynamic_cast</code> 能在运行时知道如何从 <code>Father</code> 跳回 <code>Child</code>：</strong> 它不是靠猜，而是靠读取这些像“家谱”一样的结构体。</p><hr><h3 id="_2-rtti-存在哪里" tabindex="-1"><a class="header-anchor" href="#_2-rtti-存在哪里"><span>2. RTTI 存在哪里？</span></a></h3><p>在内存布局中，它属于<strong>静态只读数据</strong>。</p><ul><li><strong>物理位置</strong>：在 ELF 文件（Linux）或 PE 文件（Windows）的 <strong><code>.rodata</code></strong>（Read-Only Data）段，或者是 <strong><code>.data.rel.ro</code></strong>（需要重定位的只读数据段）。</li><li><strong>逻辑连接</strong>：虚表（VTable）中索引为 <code>-1</code> 的位置（也就是 <code>vptr</code> 所指地址的前 8 个字节）存储了一个<strong>地址</strong>，这个地址指向了这个 RTTI 结构体。</li></ul><p><strong>直观图示：</strong></p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>[ 内存地址 ]    [ 数据内容 ]</span></span>
<span class="line"><span>0x1000         [ offset-to-top ]  (虚表开始)</span></span>
<span class="line"><span>0x1008         [ RTTI 指针      ] --------+</span></span>
<span class="line"><span>0x1010 (vptr-&gt;)[ 虚函数1 地址    ]         |</span></span>
<span class="line"><span>                                         |</span></span>
<span class="line"><span>0x2000 (RTTI)  [ Child Type Info ] &lt;------+ (位于 .rodata)</span></span>
<span class="line"><span>0x2010         [ &quot;5Child&quot; (类名) ]</span></span>
<span class="line"><span>0x2020         [ 基类 RTTI 指针   ] ----&gt; [ Father Type Info ]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_3-什么时候创建的" tabindex="-1"><a class="header-anchor" href="#_3-什么时候创建的"><span>3. 什么时候创建的？</span></a></h3><p><strong>在编译阶段（Compile Time）确定，在链接阶段（Link Time）合并。</strong></p><ol><li><strong>编译时</strong>：当编译器发现一个类包含虚函数（即它是“多态类”）时，它会自动为该类生成两样东西： <ul><li><strong>虚表（VTable）</strong>。</li><li><strong>RTTI 结构体</strong>（包含类名字符串、基类指针等）。</li></ul></li><li><strong>链接时</strong>：由于一个类可能在多个 <code>.cpp</code> 文件中被引用，编译器会在每个目标文件里都生成一份 RTTI。链接器（ld）负责把重复的 RTTI 合并，确保在整个程序运行期间，同一个类只有一个唯一的 RTTI 实例（这样才能保证 <code>typeid(a) == typeid(b)</code> 成立）。</li></ol><hr><h3 id="_4-为什么要强调-多态类-才有-rtti" tabindex="-1"><a class="header-anchor" href="#_4-为什么要强调-多态类-才有-rtti"><span>4. 为什么要强调“多态类”才有 RTTI？</span></a></h3><p>如果你定义一个普通的类：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Simple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x; };</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>编译器<strong>不会</strong>为它生成虚表，也<strong>不会</strong>为它生成 RTTI 结构。</p><ul><li>如果你对它调用 <code>typeid</code>，编译器会直接在编译时硬编码返回一个静态的结果。</li><li>如果你对它用 <code>dynamic_cast</code>，编译器会直接报错，因为它根本没地方去查“家谱”。</li></ul><p><strong>只有当你写了 <code>virtual</code>，编译器才会开启这套“魔法”支持。</strong></p><hr><ol><li><strong>物理本质</strong>：它是编译器在 <code>.rodata</code> 段生成的一组描述类继承关系的常量结构体（如 <code>__vmi_class_type_info</code>）。</li><li><strong>连接方式</strong>：它通过虚表（VTable）中负索引位置的指针与对象实例相连。</li><li><strong>核心作用</strong>： <ul><li><strong>身份识别</strong>：支持 <code>typeid</code> 运算。</li><li><strong>路径导航</strong>：为 <code>dynamic_cast</code> 提供在多重继承和虚继承树中进行地址偏移计算的“地图”。</li></ul></li><li><strong>开销限制</strong>：它只针对多态类（含有虚函数的类）生成。虽然可以通过编译选项（如 <code>-fno-rtti</code>）关闭它以节省空间（嵌入式常用），但这样会导致 <code>dynamic_cast</code> 无法使用。</li></ol><p><strong>一句话：RTTI 就是 C++ 类的“运行时户口本”。</strong></p><h1 id="空类的大小" tabindex="-1"><a class="header-anchor" href="#空类的大小"><span>空类的大小</span></a></h1><h4 id="情况-a-真正的空类-无任何成员-无虚函数" tabindex="-1"><a class="header-anchor" href="#情况-a-真正的空类-无任何成员-无虚函数"><span>情况 A：真正的空类（无任何成员，无虚函数）</span></a></h4><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Empty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>大小：1 字节</strong>。</li><li><strong>原因</strong>：C++ 要求每个对象在内存中必须有唯一的地址。如果大小为 0，那么 <code>Empty a[10]</code> 中所有元素的地址都一样，无法区分。因此编译器会插入一个“占位符”字节。</li><li><strong>例外（空基类优化 EBCO）</strong>：如果这个类被继承（例如 <code>class Derived : public Empty { int x; };</code>），派生类的大小通常是 4 字节，编译器会优化掉基类的那个 1 字节。</li></ul><h4 id="情况-b-带有虚函数的-空-类" tabindex="-1"><a class="header-anchor" href="#情况-b-带有虚函数的-空-类"><span>情况 B：带有虚函数的“空”类</span></a></h4><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> VirtualEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    virtual</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ~VirtualEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>大小：8 字节</strong>（在 64 位系统上）。</li><li><strong>原因</strong>：一旦类里有了虚函数，编译器就会为它生成 <code>vtable</code>。为了让对象能找到这个表，每个对象实例必须包含一个 <strong><code>vptr</code>（虚函数指针）</strong>。在 64 位环境下，指针的大小是 8 字节。</li></ul><hr><h3 id="图示" tabindex="-1"><a class="header-anchor" href="#图示"><span>图示</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>Memory Layout of a Virtual Class Object:</span></span>
<span class="line"><span>+-------------------+</span></span>
<span class="line"><span>|      vptr         | ----+   [vtable]</span></span>
<span class="line"><span>+-------------------+     |   +-----------------------+</span></span>
<span class="line"><span>|   member data     |     |   | offset-to-top (-2)    |  &lt;-- 用于找对象头</span></span>
<span class="line"><span>+-------------------+     |   +-----------------------+</span></span>
<span class="line"><span>                          |   | typeinfo ptr  (-1)    |  &lt;-- 用于 dynamic_cast</span></span>
<span class="line"><span>                          +-&gt; +-----------------------+</span></span>
<span class="line"><span>                              | virtual_func_1 (0)    |  &lt;-- 正常的虚函数调用</span></span>
<span class="line"><span>                              +-----------------------+</span></span>
<span class="line"><span>                              | virtual_func_2 (1)    |</span></span>
<span class="line"><span>                              +-----------------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“为什么析构函数通常要声明为 <code>virtual</code>？”<br><strong>答案：</strong> 这样可以确保当通过基类指针删除派生类对象时，程序能通过 <code>vtable</code> 找到派生类的析构函数，从而正确释放派生类特有的资源，防止内存泄漏。</p><h1 id="菱形继承与虚继承" tabindex="-1"><a class="header-anchor" href="#菱形继承与虚继承"><span>菱形继承与虚继承</span></a></h1><p><strong>虚继承（Virtual Inheritance）</strong> 是 C++ 中为了解决多重继承中著名的**“菱形继承”（Diamond Problem）**问题而引入的一种机制。</p><p>简单来说，它的核心作用是：<strong>确保在复杂的继承网络中，最顶层的基类在子类对象中只保留一份实例。</strong></p><hr><h3 id="一、-虚继承解决的问题-菱形继承" tabindex="-1"><a class="header-anchor" href="#一、-虚继承解决的问题-菱形继承"><span>一、 虚继承解决的问题：菱形继承</span></a></h3><p>想象这样一个继承关系：</p><ol><li><strong>类 A</strong>（基类）：有一个成员变量 <code>int a;</code></li><li><strong>类 B</strong> 继承自 A。</li><li><strong>类 C</strong> 继承自 A。</li><li><strong>类 D</strong> 同时继承自 B 和 C。</li></ol><h4 id="_1-如果不使用虚继承-普通继承" tabindex="-1"><a class="header-anchor" href="#_1-如果不使用虚继承-普通继承"><span>1. 如果不使用虚继承（普通继承）：</span></a></h4><p>在 <code>D</code> 类的对象内存布局中，会存在<strong>两份</strong> <code>A</code> 的拷贝：</p><ul><li>一份来自 <code>D -&gt; B -&gt; A</code></li><li>一份来自 <code>D -&gt; C -&gt; A</code></li></ul><p><strong>这会导致两个严重问题：</strong></p><ul><li><strong>数据冗余</strong>：对象 <code>D</code> 内部存了两个 <code>a</code> 变量，白白浪费内存。</li><li><strong>二义性（Ambiguity）</strong>：当你通过 <code>D</code> 的对象访问 <code>a</code> 时（例如 <code>d.a = 10;</code>），编译器会报错。因为它不知道你是想改 <code>B</code> 路径下的 <code>a</code> 还是 <code>C</code> 路径下的 <code>a</code>。你必须写成 <code>d.B::a</code> 这种丑陋的代码。</li></ul><h4 id="_2-如果使用虚继承" tabindex="-1"><a class="header-anchor" href="#_2-如果使用虚继承"><span>2. 如果使用虚继承：</span></a></h4><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a; };</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">virtual</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { ... };</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 虚继承</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">virtual</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { ... };</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 虚继承</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> D</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { ... };</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，<code>D</code> 对象中<strong>只有一份</strong> <code>A</code> 的成员。无论从 <code>B</code> 路径还是 <code>C</code> 路径去访问，操作的都是同一个 <code>a</code>。</p><hr><h3 id="二、-虚继承的-底层魔法-它是如何实现的" tabindex="-1"><a class="header-anchor" href="#二、-虚继承的-底层魔法-它是如何实现的"><span>二、 虚继承的“底层魔法”：它是如何实现的？</span></a></h3><p>虚继承的实现比普通继承复杂得多，因为它打破了“基类必须排在派生类前面”的常规布局。</p><h4 id="_1-内存布局的改变" tabindex="-1"><a class="header-anchor" href="#_1-内存布局的改变"><span>1. 内存布局的改变</span></a></h4><p>在普通继承中，子类对象只是简单地把基类成员“贴”在自己成员的前面。<br> 但在<strong>虚继承</strong>中，虚基类（即 A）的位置是<strong>不固定</strong>的。它通常被放在整个对象内存的最末尾。</p><h4 id="_2-关键组件-vbase-offset-虚基类偏移量" tabindex="-1"><a class="header-anchor" href="#_2-关键组件-vbase-offset-虚基类偏移量"><span>2. 关键组件：VBase Offset（虚基类偏移量）</span></a></h4><p>既然 <code>A</code> 的位置不固定，那么 <code>B</code> 和 <code>C</code> 在运行时怎么找到 <code>A</code> 呢？</p><p>还记得我们之前聊过的 <strong>虚表（VTable）</strong> 吗？在虚继承下，虚表里又多了一个重要的字段：<strong>VBase Offset</strong>。</p><ul><li><strong>B 的虚表</strong>里会多出一项：记录“从 B 的起始地址到 A 的起始地址需要偏移多少字节”。</li><li>当你在代码里写 <code>B* ptr = &amp;d; ptr-&gt;a = 5;</code> 时，编译器会生成这样的代码： <ol><li>查 <code>ptr</code> 指向的虚表。</li><li>找到 <strong>VBase Offset</strong>。</li><li>根据偏移量找到 <code>A</code> 的真实位置，再修改 <code>a</code>。</li></ol></li></ul><hr><h3 id="三、-虚继承下的对象布局示意图-64位系统" tabindex="-1"><a class="header-anchor" href="#三、-虚继承下的对象布局示意图-64位系统"><span>三、 虚继承下的对象布局示意图（64位系统）</span></a></h3><p>假设 <code>D</code> 继承自虚基类 <code>B</code> 和 <code>C</code>：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>[ Child D 对象的起始 ]</span></span>
<span class="line"><span>0-7   字节: vptr_B (指向 DasB 的虚表)</span></span>
<span class="line"><span>8-15  字节: B 的成员变量</span></span>
<span class="line"><span>16-23 字节: vptr_C (指向 DasC 的虚表)</span></span>
<span class="line"><span>24-31 字节: C 的成员变量</span></span>
<span class="line"><span>32-39 字节: D 的成员变量</span></span>
<span class="line"><span>40-47 字节: [ 虚基类 A 的成员 ]  &lt;-- 被挪到了最后，且全家共享这一份</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>在 B 的虚表里：</strong></p><ul><li><code>offset-to-top</code>: 0</li><li><code>vbase_offset</code>: <strong>40</strong> (告诉 B，A 在 40 字节后的位置)</li></ul><p><strong>在 C 的虚表里：</strong></p><ul><li><code>offset-to-top</code>: -16</li><li><code>vbase_offset</code>: <strong>24</strong> (16+24=40，同样指向 A)</li></ul><blockquote><p>虚表是“类”的属性，而不是“基类”的属性<br> 在内存中，class B、class C 和 class D 是三个完全不同的类。</p></blockquote><ul><li><strong>class B 的虚表</strong>：记录的是“当我是一个独立的 B 对象时，我该怎么活”。</li><li><strong>class C 的虚表</strong>：记录的是“当我是一个独立的 C 对象时，我该怎么活”。</li><li><strong>class D 的虚表组</strong>：记录的是“<strong>当我是 D 的时候，我的 B 部分、C 部分和 A 部分该怎么配合工作</strong>”。</li></ul><p>所以，D 对象里的 vptr_B 指向的绝对不是 class B 定义的那个原始虚表，而是指向 <strong>class D 专门为自己的 B 分支定制的虚表</strong>。</p><hr><blockquote><p>所以有多个vptr的原因就是要能够在通过ABC (各个父类) 的指针访问的时候能够直接找到vptr 而且能够直接找到RTII 所以可以持有父类指针进行dycast</p></blockquote><hr><h3 id="四、-虚继承的代价" tabindex="-1"><a class="header-anchor" href="#四、-虚继承的代价"><span>四、 虚继承的代价</span></a></h3><p>虽然虚继承解决了菱形继承，但它不是免费的午餐：</p><ol><li><strong>性能开销</strong>：普通继承访问基类成员是“直接寻址”，虚继承是“间接寻址”（需要查表拿偏移量），速度稍慢。</li><li><strong>内存开销</strong>：每个虚继承的子类对象都需要额外的 <code>vptr</code>（如果原本没有），且虚表体积变大。</li><li><strong>初始化责任</strong>：在虚继承中，虚基类 <code>A</code> 不再由直接派生类 <code>B</code> 或 <code>C</code> 初始化，而是由<strong>最终派生类 <code>D</code></strong> 负责初始化。这意味着 <code>D</code> 的构造函数必须显式调用 <code>A</code> 的构造函数。（如果没有默认构造函数的话）</li></ol><blockquote><p><strong>应用场景</strong>：最著名的例子是标准库中的 <strong>iostream</strong>。它继承自 istream 和 ostream，而这两者又共同虚继承自 ios。如果没有虚继承，cout 就会有两份文件状态信息。</p></blockquote><h2 id="虚基类的构造" tabindex="-1"><a class="header-anchor" href="#虚基类的构造"><span>虚基类的构造</span></a></h2><h3 id="为什么必须由-d-初始化" tabindex="-1"><a class="header-anchor" href="#为什么必须由-d-初始化"><span>为什么必须由 D 初始化？</span></a></h3><p>如果由 B 和 C 各自负责初始化 A，那么在创建 D 的对象时，A 就会被初始化<strong>两次</strong>（一次由 B 的路径，一次由 C 的路径）。这违背了虚继承“在内存中只有一份 A 实例”的初衷。</p><p>因此，C++ 规定：<strong>虚基类由“最底层”的派生类（Most Derived Class）负责初始化，中间路径上的构造函数对虚基类的调用会被自动忽略。</strong></p><hr><h3 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例"><span>代码示例</span></a></h3><p>在这个例子中，基类 <code>A</code> 没有默认构造函数，必须传一个 <code>int</code> 参数。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 1. 虚基类</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> val;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;A 构造函数被调用，val = &quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> val </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 2. 虚继承 A 的类 B</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">virtual</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // B 的构造函数试图把 x 传给 A</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;B 构造函数被调用&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 3. 虚继承 A 的类 C</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">virtual</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // C 的构造函数也试图把 x 传给 A</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;C 构造函数被调用&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 4. 最终派生类 D</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> D</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 关键点：D 必须显式调用 A 的构造函数</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 即使 B 和 C 都写了 A(x)，那些调用在创建 D 对象时都会被屏蔽</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    D</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x) { </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;D 构造函数被调用&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;--- 开始创建 D 对象 ---&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    D </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">obj</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="运行结果" tabindex="-1"><a class="header-anchor" href="#运行结果"><span>运行结果</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>--- 开始创建 D 对象 ---</span></span>
<span class="line"><span>A 构造函数被调用，val = 100</span></span>
<span class="line"><span>B 构造函数被调用</span></span>
<span class="line"><span>C 构造函数被调用</span></span>
<span class="line"><span>D 构造函数被调用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="深度解析" tabindex="-1"><a class="header-anchor" href="#深度解析"><span>深度解析</span></a></h3><h4 id="_1-如果-d-不显式调用-a-x-会怎样" tabindex="-1"><a class="header-anchor" href="#_1-如果-d-不显式调用-a-x-会怎样"><span>1. 如果 D 不显式调用 A(x) 会怎样？</span></a></h4><p>如果 <code>A</code> <strong>没有</strong>默认构造函数（无参构造函数），而 <code>D</code> 的构造函数里没写 <code>A(x)</code>，编译器会直接报错：</p><blockquote><p><code>error: no matching function for call to &#39;A::A()&#39;</code></p></blockquote><p>因为编译器认为 D 既然是“最终负责人”，它就必须负责把 A 盖起来。如果 D 没交代怎么盖 A，编译器不会去求助 B 或 C。</p><h4 id="_2-如果-a-有默认构造函数-d-没写-a-x-会怎样" tabindex="-1"><a class="header-anchor" href="#_2-如果-a-有默认构造函数-d-没写-a-x-会怎样"><span>2. 如果 A 有默认构造函数，D 没写 A(x) 会怎样？</span></a></h4><p>如果 <code>A</code> 有默认构造函数，而 <code>D</code> 没写 <code>A(x)</code>，那么：</p><ol><li><code>D</code> 会调用 <code>A</code> 的<strong>默认构造函数</strong>。</li><li><code>B</code> 和 <code>C</code> 构造函数中对 <code>A(x)</code> 的调用<strong>依然会被忽略</strong>。</li><li>结果就是 <code>obj.val</code> 可能是个随机值或默认值，而不是你想要的 100。</li></ol><h4 id="_3-构造顺序是什么" tabindex="-1"><a class="header-anchor" href="#_3-构造顺序是什么"><span>3. 构造顺序是什么？</span></a></h4><p>无论 D 的初始化列表里 <code>A(x)</code> 写在什么位置（即便写在 B 和 C 后面），<strong>虚基类 A 永远是第一个被构造的</strong>。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>“在虚继承中，为了保证虚基类在内存中只有唯一备份，C++ 规定虚基类的初始化责任由整个继承链中最底层的类承担。中间类的构造函数在初始化列表中对虚基类的调用会在运行时被屏蔽。这意味着，如果虚基类没有默认构造函数，最底层的类必须在初始化列表中显式调用虚基类的构造函数，否则无法通过编译。”</p><h2 id="菱形继承-总结" tabindex="-1"><a class="header-anchor" href="#菱形继承-总结"><span>菱形继承 总结</span></a></h2><hr><h3 id="_1-基础定义与核心矛盾" tabindex="-1"><a class="header-anchor" href="#_1-基础定义与核心矛盾"><span>1. 基础定义与核心矛盾</span></a></h3><ul><li><strong>结构描述</strong>：类 A 为基类，B 和 C 分别虚拟继承自 A，最后 D 同时继承 B 和 C。</li><li><strong>两大问题（不使用虚继承时）</strong>： <ol><li><strong>数据冗余</strong>：D 对象内部包含两份 A 的成员，浪费内存。</li><li><strong>访问二义性</strong>：通过 D 访问 A 的成员时，编译器无法确定是走 B 路径还是 C 路径。</li></ol></li></ul><h3 id="_2-解决方案-虚拟继承-virtual-inheritance" tabindex="-1"><a class="header-anchor" href="#_2-解决方案-虚拟继承-virtual-inheritance"><span>2. 解决方案：虚拟继承（Virtual Inheritance）</span></a></h3><ul><li><strong>语法</strong>：<code>class B : virtual public A</code>。</li><li><strong>核心作用</strong>：确保在整个继承体系中，虚基类 A 的子对象在最终派生类 D 中<strong>只有一份共享的实例</strong>。</li></ul><h3 id="_3-对象内存布局-核心底层逻辑" tabindex="-1"><a class="header-anchor" href="#_3-对象内存布局-核心底层逻辑"><span>3. 对象内存布局（核心底层逻辑）</span></a></h3><p>在现代编译器（如 GCC/Clang）中，D 对象的内存布局大致如下：</p><ol><li><strong>B 子对象部分</strong>：包含 <code>vptr_B</code>（D 的主虚指针，复用 B 的位置）和 B 的成员。</li><li><strong>C 子对象部分</strong>：包含 <code>vptr_C</code>（次虚指针）和 C 的成员。</li><li><strong>D 自己的成员</strong>：D 新增的变量。</li><li><strong>共享虚基类 A 部分</strong>：被挪到了对象末尾，包含 <code>vptr_A</code> 和 A 的成员。（g++中虚基类共享主虚表指针 会优化掉）</li></ol><h3 id="_4-虚表与虚指针-vptr-vtable" tabindex="-1"><a class="header-anchor" href="#_4-虚表与虚指针-vptr-vtable"><span>4. 虚表与虚指针（vptr &amp; vtable）</span></a></h3><ul><li><strong>虚表个数</strong>：D 对象通常有 <strong>3 个虚指针（vptr）</strong>，分别指向 3 个为 D 定制的“子虚表”。</li><li><strong>为什么不合并成一个 vptr？</strong><ol><li><strong>指针兼容性</strong>：必须保证 <code>B*</code>、<code>C*</code> 和 <code>A*</code> 指向 D 时，各自看到的内存布局与其基类原始布局一致（开头都是 vptr）。</li><li><strong>索引一致性</strong>：不同基类的虚函数在虚表中的索引可能冲突，必须分开。</li></ol></li><li><strong>Thunk 技术</strong>：在 <code>D-as-C</code> 或 <code>D-as-A</code> 的虚表中，若调用了 D 重写的函数，虚表存的是 Thunk 地址。其作用是：<strong>修正 <code>this</code> 指针的偏移量</strong>，使其从子对象位置跳回 D 的起始位置，再跳转到真实的函数代码。</li></ul><h3 id="_5-rtti-与指针转换" tabindex="-1"><a class="header-anchor" href="#_5-rtti-与指针转换"><span>5. RTTI 与指针转换</span></a></h3><ul><li><strong>RTTI 归属</strong>：D 对象中所有的子虚表，其 RTTI 指针最终都指向 <strong>D 的类型信息</strong>。</li><li><strong>dynamic_cast</strong>：依赖 vptr 找到虚表，再通过虚表中的 RTTI 和 <code>offset-to-top</code>（到顶部的偏移量）信息，实现安全的上下行转换。</li><li><strong>构造期切换</strong>：在构造 A、B、C 时，vptr 会经历从 A 到 B/C 再到 D 的“身份切换”，因此构造函数内调用 <code>typeid</code> 返回的是当前构造类的类型。</li></ul><h3 id="_6-初始化规则-初始化列表" tabindex="-1"><a class="header-anchor" href="#_6-初始化规则-初始化列表"><span>6. 初始化规则（初始化列表）</span></a></h3><ul><li><strong>唯一初始化权</strong>：虚基类 A 由<strong>最底层派生类 D</strong> 负责初始化。</li><li><strong>屏蔽机制</strong>：即便 B 和 C 的初始化列表中写了 A 的构造函数，当构造 D 时，B 和 C 对 A 的调用会被<strong>忽略</strong>。</li><li><strong>执行顺序</strong>： <ol><li>最先执行虚基类 <strong>A</strong> 的构造。</li><li>按声明顺序执行 <strong>B</strong>、<strong>C</strong> 的构造。</li><li>最后执行 <strong>D</strong>。<br><em>（析构顺序与之完全相反）</em></li></ol></li></ul><h3 id="_7-性能权衡-trade-offs" tabindex="-1"><a class="header-anchor" href="#_7-性能权衡-trade-offs"><span>7. 性能权衡（Trade-offs）</span></a></h3><ul><li><strong>优点</strong>：彻底解决了菱形继承的冗余和二义性。</li><li><strong>缺点</strong>： <ol><li><strong>对象变大</strong>：多了额外的 vptr 和虚表偏移信息。</li><li><strong>访问变慢</strong>：访问虚基类成员需要通过虚表做一次间接寻址（Offset 查找）。</li><li><strong>复杂性增加</strong>：内存布局复杂，调试难度高。</li></ol></li></ul><hr><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>D 对象（大小：48 bytes）</span></span>
<span class="line"><span>┌──────────── offset 0x00</span></span>
<span class="line"><span>│ B 子对象（16 bytes）</span></span>
<span class="line"><span>│   [0x00..0x07] vptr_B-in-D   ← 指向 D 的 vtable（B 视图）</span></span>
<span class="line"><span>│   [0x08..0x0B] int b = 2</span></span>
<span class="line"><span>│   [0x0C..0x0F] padding</span></span>
<span class="line"><span>├──────────── offset 0x10</span></span>
<span class="line"><span>│ C 子对象（16 bytes）</span></span>
<span class="line"><span>│   [0x10..0x17] vptr_C-in-D   ← 指向 D 的 vtable（C 视图）</span></span>
<span class="line"><span>│   [0x18..0x1B] int c = 3</span></span>
<span class="line"><span>│   [0x1C..0x1F] int d = 4     ← D 的成员变量被紧贴在此处（复用 C 尾部空间）</span></span>
<span class="line"><span>├──────────── offset 0x20</span></span>
<span class="line"><span>│ A 虚基子对象（16 bytes）</span></span>
<span class="line"><span>│   [0x20..0x27] vptr_A-in-D   ← 指向 D 的 vtable（A 视图）</span></span>
<span class="line"><span>│   [0x28..0x2B] int a = 1</span></span>
<span class="line"><span>│   [0x2C..0x2F] padding</span></span>
<span class="line"><span>└──────────── sizeof(D) = 48</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,237)])])}const k=i(l,[["render",e]]),d=JSON.parse(`{"path":"/interview/cpp.html","title":"cpp知识","lang":"zh-CN","frontmatter":{"title":"cpp知识","icon":"code-xml","description":"thread_local 关键字 类（Class）没有线程，只有操作系统（OS）有线程。 错误理解：每一个 FileDescriptor 对象都有一个线程 正确理解：你的程序可能启动了 10 个线程，这 10 个线程可能会操作同一个 FileDescriptor 对象，也可能操作 1000 个不同的 FileDescriptor 对象。 static ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"cpp知识\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-13T13:37:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yedou\\",\\"url\\":\\"https://yedou37.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://yedou37.github.io/interview/cpp.html"}],["meta",{"property":"og:site_name","content":"Yedou's Notebook"}],["meta",{"property":"og:title","content":"cpp知识"}],["meta",{"property":"og:description","content":"thread_local 关键字 类（Class）没有线程，只有操作系统（OS）有线程。 错误理解：每一个 FileDescriptor 对象都有一个线程 正确理解：你的程序可能启动了 10 个线程，这 10 个线程可能会操作同一个 FileDescriptor 对象，也可能操作 1000 个不同的 FileDescriptor 对象。 static ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-13T13:37:57.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-13T13:37:57.000Z"}]]},"git":{"createdTime":1769418021000,"updatedTime":1770989877000,"contributors":[{"name":"yedou37","username":"yedou37","email":"137401103+yedou37@users.noreply.github.com","commits":11,"url":"https://github.com/yedou37"}]},"readingTime":{"minutes":33.49,"words":10048},"filePathRelative":"interview/cpp.md","autoDesc":true}`);export{k as comp,d as data};
