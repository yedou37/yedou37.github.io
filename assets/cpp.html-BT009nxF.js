import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as n,o as t}from"./app-C3qjF5Zv.js";const l={};function e(h,s){return t(),a("div",null,[...s[0]||(s[0]=[n(`<hr><h1 id="thread-local-关键字" tabindex="-1"><a class="header-anchor" href="#thread-local-关键字"><span>thread_local 关键字</span></a></h1><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">cosnt</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> StringViewRange</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> buffers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> thread_local</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::vector</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">iovec</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> iovecs;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	// buffer -&gt; iovecs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(iovecs, total_size);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>[线程 A 的内存视角]</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>| 寄存器 fs           | ---&gt; 指向 TLS 区域</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>| TLS 区域 (Thread Local Storage)</span></span>
<span class="line"><span>| [ iovecs_A (24字节) ] --------+</span></span>
<span class="line"><span>+---------------------+         | 指针指向</span></span>
<span class="line"><span>                                v</span></span>
<span class="line"><span>                      +--------------------------+</span></span>
<span class="line"><span>                      | 堆 (Heap)                |</span></span>
<span class="line"><span>                      | [ iovec, iovec, ... ]    | &lt;--- 这里的内存被反复利用</span></span>
<span class="line"><span>                      +--------------------------+</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-------------------------------------------------------</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[线程 B 的内存视角]</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>| 寄存器 fs           | ---&gt; 指向 线程 B 自己的 TLS</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>| TLS 区域</span></span>
<span class="line"><span>| [ iovecs_B (24字节) ] --------+</span></span>
<span class="line"><span>+---------------------+         | 指针指向不同的堆地址</span></span>
<span class="line"><span>                                v</span></span>
<span class="line"><span>                      +--------------------------+</span></span>
<span class="line"><span>                      | 堆 (Heap)                |</span></span>
<span class="line"><span>                      | [ iovec, iovec, ... ]    |</span></span>
<span class="line"><span>                      +--------------------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>类（Class）没有线程，只有操作系统（OS）有线程。</strong></p><ul><li><p><strong>错误理解</strong>：每一个 FileDescriptor 对象都有一个线程</p></li><li><p><strong>正确理解</strong>：你的程序可能启动了 10 个线程，这 10 个线程可能会操作同一个 FileDescriptor 对象，也可能操作 1000 个不同的 FileDescriptor 对象。<br><strong>static thread_local 的含义是：</strong><br> 不管你创建了多少个 FileDescriptor 对象（哪怕 1 万个），<strong>只要它们是在同一个线程（Thread A）里运行的 write 函数，它们就共享同一个 iovecs 变量。</strong></p></li><li><p><strong>场景 1</strong>：线程 A 里的 socket1 调了 write，接着 socket2 也调了 write。</p><ul><li>结果：socket2 会<strong>复用</strong> socket1 刚刚用过的那块内存（前提是 socket1 用完后 vector 被 clear 了，但 capacity 还在）。效率极高！</li></ul></li><li><p><strong>场景 2</strong>：线程 A 里的 socket1 和线程 B 里的 socket1 同时调 write。</p><ul><li>结果：线程 A 用的是 iovecs_A，线程 B 用的是 iovecs_B。互不干扰，不需要加锁。</li></ul></li><li><p><strong>出生（构造）</strong>：</p><ul><li>当<strong>某个线程第一次</strong>运行到 write 函数内部的那一行代码时，这个线程专属的 iovecs 被构造。</li><li>如果你有 10 个线程，但只有 3 个线程调用过 write，那就只有 3 个 iovecs 被创建。</li></ul></li><li><p><strong>存活</strong>：</p><ul><li>只要这个<strong>线程</strong>还活着，这个变量就一直活着（保留着堆内存）。</li><li>它<strong>不随对象的销毁而销毁</strong>。即使你把所有的 FileDescriptor 对象都析构了，只要线程还在，这个 iovecs 依然占着内存等待下一次召唤。</li></ul></li><li><p><strong>死亡（析构）</strong>：</p><ul><li>当<strong>线程退出（Thread Exit）</strong> 时。</li><li>C++ 运行时环境会自动遍历该线程所有的 thread_local 变量，调用它们的析构函数，从而释放那块堆内存，最后清理 TLS 里的头信息。</li></ul></li></ul><h3 id="static-是什么意思-在函数内部" tabindex="-1"><a class="header-anchor" href="#static-是什么意思-在函数内部"><span>static 是什么意思？（在函数内部）</span></a></h3><p>当 static 用于函数内部的局部变量时，它改变的是变量的 <strong>生命周期（Lifecycle）</strong> 和 <strong>存储位置</strong>。</p><ul><li><strong>普通局部变量</strong> (int a = 0;) <ul><li><strong>存储位置</strong>：栈（Stack）。</li><li><strong>生命周期</strong>：函数被调用时创建，函数返回时销毁。下次调用时是全新的。</li><li><strong>比喻</strong>：便利贴。用完就撕了扔掉。</li></ul></li><li><strong>静态局部变量</strong> (static int a = 0;)： <ul><li><strong>存储位置</strong>：数据段（Data Segment / BSS）。</li><li><strong>生命周期</strong>：<strong>整个程序运行期间</strong>。它在程序第一次运行到这行代码时初始化，直到程序结束才销毁。</li><li><strong>比喻</strong>：墙上的白板。你写了字，离开房间再回来，字还在那里。</li></ul></li></ul><hr><h3 id="thread-local-是什么意思" tabindex="-1"><a class="header-anchor" href="#thread-local-是什么意思"><span>thread_local 是什么意思？</span></a></h3><p>它改变的是变量的 <strong>实例数量</strong> 和 <strong>归属权</strong>。</p><ul><li><strong>没有 thread_local</strong>： <ul><li>全局只有一份（如果是 static）。所有线程看到的都是同一个变量，改的也是同一个。</li><li><strong>后果</strong>：多线程同时改会打架（Data Race），必须加锁。</li></ul></li><li><strong>有 thread_local</strong>： <ul><li>每个线程都有一份独立的拷贝。</li><li><strong>生命周期</strong>：<strong>与线程绑定</strong>。线程启动（或第一次使用）时创建，线程结束时销毁。</li></ul></li></ul><hr><h1 id="std-unique-ptr-std-make-unique" tabindex="-1"><a class="header-anchor" href="#std-unique-ptr-std-make-unique"><span><code>std::unique_ptr&lt;&gt; std::make_unique&lt;&gt;()</code></span></a></h1><ol><li><strong><code>std::unique_ptr</code> (霸道总裁)</strong>： <ul><li>它是<strong>管理者</strong>。</li><li>它的座右铭是：“<strong>这块内存是我的，只能是我的，谁也别想复制，但我死了这块内存也别想活。</strong>”</li><li>它通过 RAII（资源获取即初始化）机制，保证出了作用域自动释放内存。</li></ul></li><li><strong><code>std::make_unique</code> (专属工厂)</strong>： <ul><li>它是<strong>生产者</strong>。</li><li>它的作用是：“<strong>别自己瞎折腾去 new 了，把要求告诉我，我帮你造好打包送给你。</strong>”</li><li>它是 C++14 引入的辅助函数，用来生成 <code>unique_ptr</code>。<br> 独占所有权-&gt;不能拷贝 只能移动<br> 零开销</li></ul></li></ol><ul><li>unique_ptr 内部只存了一个裸指针。</li><li>如果你不使用自定义删除器（Deleter），它的大小和 int* 完全一样（64位系统下就是 8 字节）。</li><li>它的解引用操作 *ptr 和 ptr-&gt; 会被编译器优化成和裸指针一模一样的汇编指令</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">process</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()), std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>C++ 编译器在编译这行代码时，执行顺序是不确定的（Unspecified Evaluation Order）。它可能这样执行：</p><ol><li>new A() 分配成功。</li><li><strong>执行 new B() —— 此时内存不足抛出异常！</strong></li><li><code>std::unique_ptr&lt;A&gt;</code> 的构造函数还没来得及执行。</li><li><strong>结果</strong>：A 的指针丢失了，没人负责 delete 它，<strong>内存泄漏</strong>。</li></ol><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">process</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">make_unique</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(), std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">make_unique</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>make_unique 内部封装了 new 和 unique_ptr 的构造。它是一个完整的函数调用。<br> 这意味着步骤变成了：</p><ol><li>完整执行 <code>make_unique&lt;A&gt;()</code>（分配+包装）。成功后返回一个对象。</li><li>完整执行 <code>make_unique&lt;B&gt;()</code>。</li><li><strong>如果 B 失败了，A 已经是一个智能指针对象了，它会自动析构释放内存。</strong></li><li><strong>结论：零泄漏风险。</strong></li></ol><h1 id="使用工厂函数" tabindex="-1"><a class="header-anchor" href="#使用工厂函数"><span>使用工厂函数</span></a></h1><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 方式1：不使用工厂函数（复杂）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TypeId</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int32_t</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">type_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(type), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">value_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(value) {}</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TypeId</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">type_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(type) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 复杂的字符串处理逻辑</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 内存管理逻辑</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TypeId</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">type_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(type), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">value_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#ABB2BF;">static_cast</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;int8_t&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(value)) {}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 使用时需要记住复杂的构造方式</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> int_val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(TypeId::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">INTEGER</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> bool_val</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(TypeId::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BOOLEAN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">static_cast</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int8_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 需要手动转换</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 方式2：使用工厂函数（简洁）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ValueFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> inline</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetIntegerValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int32_t</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {TypeId::INTEGER, value};</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> inline</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> auto</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetBooleanValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {TypeId::BOOLEAN, </span><span style="--shiki-light:#A626A4;--shiki-dark:#ABB2BF;">static_cast</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;int8_t&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(value)};</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 使用时非常简单直观</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Value int_val </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ValueFactory::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetIntegerValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Value bool_val </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ValueFactory::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetBooleanValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工厂函数一般都使用static 因为这样函数只属于这个工厂类本身 不需要实例化一个ValueFactory对象 能够直接通过这个类名进行调用 而且可以在全局范围内进行访问<br> 优点</p><ul><li>能够统一接口</li><li>易于扩展 如果需要支持新的类别的话 直接在工厂中添加新方法即可</li><li>隐藏复杂度</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">protected:</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) : </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">type_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(type), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">x_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x), </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">y_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(y) {}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreatePlayer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> player </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;player&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, x, y));</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        player</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setHealth</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        player</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setSpeed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> player;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreateEnemy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> enemy </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;enemy&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, x, y));</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        enemy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setHealth</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        enemy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setSpeed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        enemy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setAggressive</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> enemy;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreateItem</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> itemType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> item </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unique_ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;item&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, x, y));</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        item</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setItemProperties</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(itemType);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> item;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 使用</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> player </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> GameObject::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreatePlayer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> enemy </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> GameObject::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreateEnemy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> potion </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> GameObject::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CreateItem</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;health_potion&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如这里都是创建游戏中的对象 可以使用工厂函数 更加简单直观地进行构造</p><h1 id="top-k" tabindex="-1"><a class="header-anchor" href="#top-k"><span>TOP-K</span></a></h1><hr><h3 id="_1-场景一-单机内存处理-static-data-fit-in-memory" tabindex="-1"><a class="header-anchor" href="#_1-场景一-单机内存处理-static-data-fit-in-memory"><span>1. 场景一：单机内存处理（Static Data, Fit in Memory）</span></a></h3><p>假设给你一个包含 $N$ 个整数的数组，内存放得下，找出最大的 $K$ 个。</p><h4 id="方法-a-全量排序-naive-approach" tabindex="-1"><a class="header-anchor" href="#方法-a-全量排序-naive-approach"><span>方法 A：全量排序 (Naive Approach)</span></a></h4><ul><li><strong>做法</strong>：使用 <code>std::sort</code> (QuickSort/MergeSort) 将数组完全排序，然后取前 $K$ 个。</li><li><strong>复杂度</strong>：$O(N \\log N)$。</li><li><strong>评价</strong>：<strong>最差</strong>。当 $N$ 很大而 $K$ 很小时（例如 $N=1000万, K=10$），做了大量无用功。</li></ul><h4 id="方法-b-最小堆-min-heap-——-工程首选" tabindex="-1"><a class="header-anchor" href="#方法-b-最小堆-min-heap-——-工程首选"><span>方法 B：最小堆 (Min-Heap) —— <strong>工程首选</strong></span></a></h4><ul><li><strong>做法</strong>： <ol><li>维护一个大小为 $K$ 的<strong>小顶堆</strong>。</li><li>遍历数组，将元素压入堆。</li><li>如果堆的大小超过 $K$，弹出堆顶（即堆中最小的元素，也就是当前 Top K 里最弱的那个）。</li><li>最终堆里剩下的就是最大的 $K$ 个。</li></ol></li><li><strong>复杂度</strong>：$O(N \\log K)$。</li><li><strong>评价</strong>：<strong>最通用、最稳健</strong>。特别是当 $K \\ll N$ 时，效率极高。你优化后的代码用的就是这个。</li></ul><h4 id="方法-c-快速选择-quick-select-——-平均最快" tabindex="-1"><a class="header-anchor" href="#方法-c-快速选择-quick-select-——-平均最快"><span>方法 C：快速选择 (Quick Select) —— <strong>平均最快</strong></span></a></h4><ul><li><strong>做法</strong>：基于快速排序（Quick Sort）的 Partition 思想。 <ol><li>随机选一个 Pivot，将数组分为“比 Pivot 大”和“比 Pivot 小”两部分。</li><li>看 Pivot 的位置： <ul><li>如果 Pivot 正好在第 $K$ 个位置，那么它左边的就是 Top K。</li><li>如果 Pivot 在 $K$ 之后，递归处理左边。</li><li>如果 Pivot 在 $K$ 之前，递归处理右边。</li></ul></li></ol></li><li><strong>复杂度</strong>：平均 $O(N)$，最坏 $O(N^2)$。</li><li><strong>评价</strong>：<strong>理论最快</strong>，但修改了原数组，且不稳定。C++ 标准库中有 <code>std::nth_element</code> 就是这个实现。</li></ul><hr><h3 id="_2-场景二-海量数据-流式数据-streaming-data" tabindex="-1"><a class="header-anchor" href="#_2-场景二-海量数据-流式数据-streaming-data"><span>2. 场景二：海量数据/流式数据（Streaming Data）</span></a></h3><p>假设数据是实时流进来的（像网络包、日志），或者数据在磁盘上，内存放不下 $N$ 个元素。</p><ul><li><strong>限制</strong>：无法将所有数据加载到内存，无法使用 Quick Select。</li><li><strong>唯一解法：最小堆 (Min-Heap)</strong>。 <ul><li><strong>原理</strong>：不管 $N$ 有多大（1TB 甚至无穷大），内存中只需要维护一个 $K$ 大小的堆。</li><li><strong>空间复杂度</strong>：$O(K)$。</li></ul></li><li><strong>应用</strong>：实时热搜榜、DDOS 攻击检测（流量最大的 K 个 IP）。</li></ul><hr><h3 id="_3-场景三-分布式大数据-distributed-big-data" tabindex="-1"><a class="header-anchor" href="#_3-场景三-分布式大数据-distributed-big-data"><span>3. 场景三：分布式大数据（Distributed / Big Data）</span></a></h3><p>假设有 10 亿行数据，分布在 1000 台机器上，要找全局 Top-K。</p><ul><li><strong>限制</strong>：单机算不动，网络带宽有限。</li><li><strong>解法：分治法 (MapReduce 思想)</strong><ol><li><strong>Map 阶段</strong>：每台机器在本地数据上计算<strong>局部 Top-K</strong>（使用堆）。</li><li><strong>Reduce 阶段</strong>：每台机器将这 $K$ 个元素发送给一台中心机器（或者下一层聚合节点）。</li><li><strong>Merge 阶段</strong>：中心机器收集到 $1000 \\times K$ 个元素，再做一次 Top-K，得到全局 Top-K。</li></ol></li><li><strong>关键点</strong>：传输的数据量非常小（只有 $K$），而不是 $N$。</li></ul><hr><h3 id="_4-场景四-统计-频率-最高的-top-k-heavy-hitters" tabindex="-1"><a class="header-anchor" href="#_4-场景四-统计-频率-最高的-top-k-heavy-hitters"><span>4. 场景四：统计“频率”最高的 Top-K (Heavy Hitters)</span></a></h3><p>上面的场景都是基于元素的值（Value）排序。如果问题是：<strong>“在一个 100GB 的日志文件中，找出出现次数最多的 10 个 IP 地址”</strong>。</p><p>这是一个难点，因为你不仅要排序，还要先<strong>统计计数</strong>。</p><h4 id="方法-a-hash-map-heap-精确解" tabindex="-1"><a class="header-anchor" href="#方法-a-hash-map-heap-精确解"><span>方法 A：Hash Map + Heap (精确解)</span></a></h4><ul><li><strong>做法</strong>：用 Hash Map 统计所有 IP 的出现次数，然后把 (IP, Count) 扔进堆里求 Top-K。</li><li><strong>缺点</strong>：如果有 10 亿个不同的 IP，Hash Map 内存会爆炸。</li></ul><h4 id="方法-b-hash-分片-精确解-分布式" tabindex="-1"><a class="header-anchor" href="#方法-b-hash-分片-精确解-分布式"><span>方法 B：Hash 分片 (精确解，分布式)</span></a></h4><ul><li><strong>做法</strong>： <ol><li>把 IP 按照 <code>hash(IP) % 1024</code> 分发到 1024 个小文件中。</li><li>这样相同的 IP 肯定在同一个文件里。</li><li>分别加载每个小文件到内存，用 Hash Map 统计并求局部 Top-K。</li><li>最后归并。</li></ol></li></ul><h4 id="方法-c-count-min-sketch-misra-gries-近似解" tabindex="-1"><a class="header-anchor" href="#方法-c-count-min-sketch-misra-gries-近似解"><span>方法 C：Count-Min Sketch / Misra-Gries (近似解)</span></a></h4><ul><li><strong>场景</strong>：允许一点点误差，但必须极省内存（比如路由器硬件）。</li><li><strong>做法</strong>：使用概率数据结构（如 Count-Min Sketch）。 <ul><li>用多个 Hash 函数将元素映射到二维数组中进行计数。</li><li>不需要存储 IP 本身，只存储计数值。</li><li><strong>优点</strong>：用极小的空间（几KB）就能统计海量数据。</li></ul></li></ul><hr><h3 id="_5-数据库中的-top-k-优化" tabindex="-1"><a class="header-anchor" href="#_5-数据库中的-top-k-优化"><span>5. 数据库中的 Top-K 优化</span></a></h3><p><code>SELECT * FROM table ORDER BY col LIMIT K</code>。</p><p>数据库优化器通常会按以下顺序尝试：</p><ol><li><p><strong>利用索引 (Index Scan)</strong>：</p><ul><li>如果在 <code>col</code> 上有 B+ 树索引，索引本身就是有序的。</li><li>数据库只需要读索引的最左边（或最右边）的 $K$ 个条目。</li><li><strong>复杂度</strong>：$O(K)$。这是极速模式。</li></ul></li><li><p>**Top-N Heap Sort：</p><ul><li>如果没索引，必须全表扫描。</li><li>在扫描过程中维护一个大小为 $K$ 的堆。</li><li><strong>复杂度</strong>：$O(N \\log K)$。</li></ul></li><li><p><strong>全量排序 (External Sort)</strong>：</p><ul><li>如果 $K$ 非常大（比如 <code>LIMIT 1000000</code>），堆太大内存放不下。</li><li>退化为外部归并排序。</li></ul></li></ol><h3 id="总结表" tabindex="-1"><a class="header-anchor" href="#总结表"><span>总结表</span></a></h3><table><thead><tr><th style="text-align:left;">场景</th><th style="text-align:left;">最佳策略</th><th style="text-align:left;">复杂度</th><th style="text-align:left;">备注</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>内存充足，静态数据</strong></td><td style="text-align:left;"><strong>Quick Select</strong></td><td style="text-align:left;">$O(N)$</td><td style="text-align:left;">会修改原数组</td></tr><tr><td style="text-align:left;"><strong>内存充足，一般通用</strong></td><td style="text-align:left;"><strong>Min-Heap</strong></td><td style="text-align:left;">$O(N \\log K)$</td><td style="text-align:left;">不改原数组，稳定</td></tr><tr><td style="text-align:left;"><strong>流式数据 (Streaming)</strong></td><td style="text-align:left;"><strong>Min-Heap</strong></td><td style="text-align:left;">$O(N \\log K)$</td><td style="text-align:left;">空间仅需 $O(K)$</td></tr><tr><td style="text-align:left;"><strong>海量数据 (分布式)</strong></td><td style="text-align:left;"><strong>分治 + 归并</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">MapReduce 经典案例</td></tr><tr><td style="text-align:left;"><strong>高频词统计 (精确)</strong></td><td style="text-align:left;"><strong>Hash分片 + Heap</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">解决 Map 内存爆炸问题</td></tr><tr><td style="text-align:left;"><strong>高频词统计 (近似)</strong></td><td style="text-align:left;"><strong>Count-Min Sketch</strong></td><td style="text-align:left;">$O(1)$ 空间</td><td style="text-align:left;">牺牲精度换空间</td></tr></tbody></table>`,64)])])}const r=i(l,[["render",e]]),d=JSON.parse(`{"path":"/interview/cpp.html","title":"cpp知识","lang":"zh-CN","frontmatter":{"title":"cpp知识","icon":"code-xml","description":"thread_local 关键字 类（Class）没有线程，只有操作系统（OS）有线程。 错误理解：每一个 FileDescriptor 对象都有一个线程 正确理解：你的程序可能启动了 10 个线程，这 10 个线程可能会操作同一个 FileDescriptor 对象，也可能操作 1000 个不同的 FileDescriptor 对象。 static ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"cpp知识\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-02T13:53:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yedou\\",\\"url\\":\\"https://yedou37.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://yedou37.github.io/interview/cpp.html"}],["meta",{"property":"og:site_name","content":"Yedou's Notebook"}],["meta",{"property":"og:title","content":"cpp知识"}],["meta",{"property":"og:description","content":"thread_local 关键字 类（Class）没有线程，只有操作系统（OS）有线程。 错误理解：每一个 FileDescriptor 对象都有一个线程 正确理解：你的程序可能启动了 10 个线程，这 10 个线程可能会操作同一个 FileDescriptor 对象，也可能操作 1000 个不同的 FileDescriptor 对象。 static ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-02T13:53:46.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-02T13:53:46.000Z"}]]},"git":{"createdTime":1769418021000,"updatedTime":1770040426000,"contributors":[{"name":"yedou37","username":"yedou37","email":"137401103+yedou37@users.noreply.github.com","commits":9,"url":"https://github.com/yedou37"}]},"readingTime":{"minutes":9.99,"words":2998},"filePathRelative":"interview/cpp.md","autoDesc":true}`);export{r as comp,d as data};
